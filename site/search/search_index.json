{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Conduit","text":"<p>Zero-copy pub/sub middleware for robotics.</p> <p>Conduit is a lightweight IPC framework built for robotics engineers who want to focus on robotics, not fight their middleware.</p>"},{"location":"#features","title":"Features","text":"Feature Description Zero-copy transport Messages written once to shared memory, read directly by subscribers Lock-free No mutexes, no deadlocks, crashed processes don't block others Zero CPU when idle Futex-based signaling \u2014 sleeping subscribers use no CPU Typed messages Compile-time validated <code>Publisher&lt;T&gt;</code> / <code>Subscriber&lt;T&gt;</code> with built-in types Simple API Node class handles threading, signal handling, and callbacks YAML flow files Readable launch files that do exactly what they say Built-in recording MCAP format with Zstd/LZ4 compression CLI tools Monitor topics, measure rates, record data"},{"location":"#quick-look","title":"Quick Look","text":"<pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_types/derived/imu.hpp&gt;\n#include &lt;conduit_types/primitives/vec3.hpp&gt;\n\nusing namespace conduit;\n\nclass MyNode : public Node {\npublic:\n    MyNode() {\n        subscribe&lt;Imu&gt;(\"imu\", &amp;MyNode::on_imu);\n        pub_.emplace(advertise&lt;Vec3&gt;(\"output\"));\n        loop(100.0, &amp;MyNode::control);  // 100 Hz\n    }\n\nprivate:\n    void on_imu(const TypedMessage&lt;Imu&gt;&amp; msg) {\n        std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n        latest_accel_ = msg.data.linear_acceleration;\n    }\n\n    void control() {\n        Vec3 cmd{};\n        {\n            std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n            cmd = latest_accel_;\n        }\n        pub_-&gt;publish(cmd);\n    }\n\n    std::mutex mutex_;\n    Vec3 latest_accel_{};\n    std::optional&lt;Publisher&lt;Vec3&gt;&gt; pub_;\n};\n\nint main() {\n    MyNode node;\n    node.run();  // Blocks until Ctrl+C\n}\n</code></pre>"},{"location":"#performance","title":"Performance","text":"Operation Latency Publish (small message) ~200-500 ns Publish (1 MB) ~100-200 us Subscriber wake ~2-5 us"},{"location":"#packages","title":"Packages","text":"Package Description <code>conduit_core</code> Shared memory, ring buffer, pub/sub, node <code>conduit_types</code> Message types: primitives, derived composites, serialization helpers <code>conduit_tank</code> MCAP recording with compression <code>conduit_flow</code> Flow file execution engine <code>conduit_tools</code> CLI (topics, echo, hz, record, flow) <code>conduit_demo</code> Example publisher and subscriber"},{"location":"cli/","title":"CLI Tools","text":"<p>The <code>conduit</code> command provides tools for monitoring and recording.</p> <pre><code>conduit &lt;command&gt; [options]\n</code></pre>"},{"location":"cli/#bash-completion","title":"Bash Completion","text":"<p>Enable tab completion for commands, topics, and flow names:</p> <pre><code>source install/share/conduit/completion/conduit.bash\n</code></pre> <p>Add to your <code>.bashrc</code> for permanent setup.</p>"},{"location":"cli/#topics","title":"topics","text":"<p>List all active topics.</p> <pre><code>$ conduit topics\ncamera\nimu\nlidar\nodom\n</code></pre> <p>Topics are discovered by scanning <code>/dev/shm/conduit_*</code>.</p>"},{"location":"cli/#info","title":"info","text":"<p>Show metadata for a topic.</p> <pre><code>$ conduit info imu\nTopic: imu\n  Slot count: 16\n  Slot size: 4096\n  Max message: 4076 bytes\n  Subscribers: 2\n  Messages published: 15420\n</code></pre>"},{"location":"cli/#echo","title":"echo","text":"<p>Print messages as they arrive.</p> <pre><code>$ conduit echo imu\n[seq=1000 ts=1705312345678901234] size=48\n  00 00 00 00 00 00 f0 3f  00 00 00 00 00 00 00 00  ........?.......\n  9a 99 99 3e cd cc 4c 3f  00 00 80 3f 00 00 00 00  ...&gt;..L?...?....\n  00 00 00 00 00 00 00 00                           ........\n[seq=1001 ts=1705312345688901234] size=48\n  ...\n^C\n</code></pre> <p>Press <code>Ctrl+C</code> to stop.</p>"},{"location":"cli/#hz","title":"hz","text":"<p>Measure publication rate.</p> <pre><code>$ conduit hz imu\nMeasuring imu...\n  Rate: 99.8 Hz (avg 50 msgs)\n  Rate: 100.1 Hz (avg 100 msgs)\n  Rate: 100.0 Hz (avg 150 msgs)\n^C\n</code></pre> <p>Useful for verifying sensors and publishers are running at expected rates.</p>"},{"location":"cli/#record","title":"record","text":"<p>Record topics to an MCAP file.</p> <pre><code># Record specific topics\nconduit record -o data.mcap imu camera odom\n\n# Record all active topics\nconduit record -o data.mcap --all\n</code></pre> <p>Press <code>Ctrl+C</code> to stop recording.</p> <p>Output format: MCAP with Zstd compression.</p> <p>Options:</p> Option Description <code>-o, --output FILE</code> Output file path (required) <code>--all</code> Record all active topics"},{"location":"cli/#flow","title":"flow","text":"<p>Run a flow file to orchestrate multiple nodes.</p> <pre><code># Run by name (resolves from installed flows)\nconduit flow demo\n\n# Run by path\nconduit flow ./my_system.flow.yaml\n</code></pre> <p>Press <code>Ctrl+C</code> for graceful shutdown (runs shutdown sequence).</p>"},{"location":"cli/#flow-name-resolution","title":"Flow Name Resolution","text":"<p>When you pass a name (no <code>/</code> or <code>.yaml</code>), Conduit looks for matching flow files in the installed flows directory (<code>&lt;install&gt;/share/conduit/flows/</code>):</p> <ol> <li><code>&lt;name&gt;.flow.yaml</code></li> <li><code>&lt;name&gt;.yaml</code></li> </ol> <p>This means any package can install flow files and they become available by name.</p>"},{"location":"cli/#list-available-flows","title":"List Available Flows","text":"<pre><code>$ conduit flow --list\ndemo\nrobot\n</code></pre>"},{"location":"cli/#flow-file-format","title":"Flow File Format","text":"<pre><code>startup:\n  - driver_node                    # Simple: exec = \"driver_node\"\n  - name: perception               # With options\n    exec: /path/to/perception\n    args: [\"--config\", \"params.yaml\"]\n    env:\n      MODEL_PATH: /models\n  - wait: topic:camera             # Wait for topic to exist\n  - wait: 500ms                    # Wait duration\n  - wait: [topic:a, topic:b]       # Wait for multiple topics\n  - group:                         # Start in parallel\n      - planner\n      - controller\n\nshutdown:                          # Optional (default: reverse of startup)\n  - controller\n  - wait: 100ms\n  - planner\n</code></pre>"},{"location":"cli/#step-types","title":"Step Types","text":"Type Example Description Node (simple) <code>- my_node</code> Start executable <code>my_node</code> Node (full) <code>- name: x, exec: /path</code> Start with options Wait duration <code>- wait: 1s</code> Pause (s, ms, us, ns) Wait topic <code>- wait: topic:imu</code> Wait until topic exists Wait multiple <code>- wait: [topic:a, topic:b]</code> Wait for all topics Group <code>- group: [a, b, c]</code> Start nodes in parallel"},{"location":"cli/#node-options","title":"Node Options","text":"<pre><code>- name: my_node           # Identifier for logging\n  exec: /path/to/binary   # Executable (default: name)\n  args: [\"--flag\", \"val\"] # Command line arguments\n  env:                    # Environment variables\n    KEY: value\n  working_dir: /path      # Working directory\n</code></pre>"},{"location":"cli/#installing-flow-files","title":"Installing Flow Files","text":"<p>Add to your package's <code>CMakeLists.txt</code>:</p> <pre><code>install(FILES my_flow.flow.yaml DESTINATION share/conduit/flows)\n</code></pre> <p>After building, <code>conduit flow my_flow</code> will find it.</p>"},{"location":"cli/#examples","title":"Examples","text":""},{"location":"cli/#monitor-a-robot","title":"Monitor a Robot","text":"<pre><code># Terminal 1: Watch what topics exist\nwatch -n 1 conduit topics\n\n# Terminal 2: Check IMU rate\nconduit hz imu\n\n# Terminal 3: See raw messages\nconduit echo cmd_vel\n</code></pre>"},{"location":"cli/#record-a-test-run","title":"Record a Test Run","text":"<pre><code># Start recording\nconduit record -o test_run_001.mcap imu camera odom cmd_vel\n\n# ... run your test ...\n\n# Ctrl+C to stop\n# File saved: test_run_001.mcap\n</code></pre>"},{"location":"cli/#launch-a-system","title":"Launch a System","text":"<pre><code># robot.flow.yaml\nstartup:\n  - imu_driver\n  - camera_driver\n  - wait: [topic:imu, topic:camera]\n  - localization\n  - wait: topic:pose\n  - navigation\n  - teleop\n</code></pre> <pre><code>conduit flow robot\n# Ctrl+C for graceful shutdown\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Get Conduit running in under 5 minutes.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker</li> <li>Linux host (for shared memory)</li> </ul>"},{"location":"getting-started/#setup","title":"Setup","text":""},{"location":"getting-started/#1-clone-and-enter-the-repo","title":"1. Clone and enter the repo","text":"<pre><code>git clone https://github.com/venkisagunner93/conduit.git\ncd conduit\n</code></pre>"},{"location":"getting-started/#2-source-the-helper-script","title":"2. Source the helper script","text":"<pre><code>source conduit.sh\n</code></pre> <p>This adds shell commands:</p> Command Description <code>cbuild</code> Build the Docker image <code>crun</code> Start the container <code>cexec</code> Exec into running container <code>cforge</code> Install the forge build tool"},{"location":"getting-started/#3-build-and-enter-the-container","title":"3. Build and enter the container","text":"<pre><code>cbuild    # Build Docker image (one-time)\ncrun      # Start container\n</code></pre> <p>You're now inside the container at <code>/home/docker_user/workspace</code>.</p>"},{"location":"getting-started/#4-install-forge-and-build","title":"4. Install forge and build","text":"<pre><code>cforge        # Install build tool\nforge build   # Build all packages\n</code></pre>"},{"location":"getting-started/#5-set-up-your-environment","title":"5. Set up your environment","text":"<pre><code>source install/setup.bash\n</code></pre> <p>This adds <code>install/bin</code> to your PATH.</p>"},{"location":"getting-started/#run-the-demo","title":"Run the Demo","text":"<p>Open three terminals (use <code>cexec</code> to attach to the running container).</p> <p>Terminal 1 \u2014 Publisher: <pre><code>demo-publisher\n</code></pre></p> <p>Terminal 2 \u2014 Subscriber: <pre><code>demo-subscriber\n</code></pre></p> <p>Terminal 3 \u2014 Monitor: <pre><code>conduit topics      # List topics\nconduit hz hello    # Measure rate\nconduit echo hello  # See messages\n</code></pre></p> <p>Or launch everything with a flow:</p> <pre><code>conduit flow demo\n</code></pre>"},{"location":"getting-started/#create-your-first-node","title":"Create Your First Node","text":""},{"location":"getting-started/#1-create-a-package","title":"1. Create a package","text":"<pre><code>forge pkg my_robot --deps conduit_core conduit_types\n</code></pre> <p>This creates: <pre><code>packages/my_robot/\n\u251c\u2500\u2500 conduit.toml\n\u251c\u2500\u2500 CMakeLists.txt\n\u251c\u2500\u2500 include/my_robot/my_robot.hpp\n\u251c\u2500\u2500 src/my_robot.cpp\n\u2514\u2500\u2500 tests/my_robot_test.cpp\n</code></pre></p>"},{"location":"getting-started/#2-write-a-publisher","title":"2. Write a publisher","text":"<p>Edit <code>packages/my_robot/src/my_robot.cpp</code>:</p> <pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_core/log.hpp&gt;\n#include &lt;conduit_types/primitives/uint.hpp&gt;\n#include &lt;optional&gt;\n\nusing namespace conduit;\n\nclass MyPublisher : public Node {\npublic:\n    MyPublisher() {\n        pub_.emplace(advertise&lt;Uint&gt;(\"my_topic\"));\n        loop(10.0, &amp;MyPublisher::publish);\n    }\n\nprivate:\n    void publish() {\n        Uint msg{};\n        msg.value = count_++;\n        pub_-&gt;publish(msg);\n        log::info(\"Sent: {}\", msg.value);\n    }\n\n    std::optional&lt;Publisher&lt;Uint&gt;&gt; pub_;\n    uint64_t count_ = 0;\n};\n\nint main() {\n    MyPublisher node;\n    node.run();\n}\n</code></pre>"},{"location":"getting-started/#3-write-a-subscriber","title":"3. Write a subscriber","text":"<pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_core/log.hpp&gt;\n#include &lt;conduit_types/primitives/uint.hpp&gt;\n\nusing namespace conduit;\n\nclass MySubscriber : public Node {\npublic:\n    MySubscriber() {\n        subscribe&lt;Uint&gt;(\"my_topic\", &amp;MySubscriber::on_message);\n    }\n\nprivate:\n    void on_message(const TypedMessage&lt;Uint&gt;&amp; msg) {\n        log::info(\"Received [seq={}]: {}\", msg.sequence, msg.data.value);\n    }\n};\n\nint main() {\n    MySubscriber node;\n    node.run();\n}\n</code></pre>"},{"location":"getting-started/#4-update-cmakeliststxt","title":"4. Update CMakeLists.txt","text":"<pre><code>cmake_minimum_required(VERSION 3.16)\nproject(my_robot LANGUAGES CXX)\n\nset(CMAKE_CXX_STANDARD 17)\nset(CMAKE_CXX_STANDARD_REQUIRED ON)\n\nfind_package(conduit_core REQUIRED)\nfind_package(conduit_types REQUIRED)\n\nadd_executable(my_publisher src/my_robot.cpp)\ntarget_link_libraries(my_publisher conduit_core::conduit_core)\n\ninstall(TARGETS my_publisher RUNTIME DESTINATION bin)\n</code></pre>"},{"location":"getting-started/#5-build-and-run","title":"5. Build and run","text":"<pre><code>forge build my_robot\n./install/bin/my_publisher\n</code></pre> <p>In another terminal: <pre><code>conduit echo my_topic\n</code></pre></p>"},{"location":"getting-started/#project-structure","title":"Project Structure","text":"<pre><code>conduit/\n\u251c\u2500\u2500 packages/           # All Conduit packages\n\u2502   \u251c\u2500\u2500 conduit_core/   # Core library\n\u2502   \u251c\u2500\u2500 conduit_types/  # Message types\n\u2502   \u251c\u2500\u2500 conduit_tank/   # Recording\n\u2502   \u251c\u2500\u2500 conduit_flow/   # Flow execution\n\u2502   \u251c\u2500\u2500 conduit_tools/  # CLI\n\u2502   \u2514\u2500\u2500 conduit_demo/   # Examples\n\u251c\u2500\u2500 tools/\n\u2502   \u2514\u2500\u2500 conduit-forge/  # Build tool\n\u251c\u2500\u2500 install/            # Built binaries and libraries\n\u251c\u2500\u2500 build/              # Build artifacts\n\u2514\u2500\u2500 conduit.sh          # Helper script\n</code></pre>"},{"location":"getting-started/#build-commands","title":"Build Commands","text":"<pre><code>forge build              # Build all packages\nforge build &lt;package&gt;    # Build specific package\nforge test               # Run all tests\nforge list               # Show packages and build order\nforge clean              # Remove build artifacts\nforge pkg &lt;name&gt;         # Create new package\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Publisher API \u2014 How to publish typed messages</li> <li>Subscriber API \u2014 How to subscribe to topics</li> <li>Types \u2014 Built-in message types</li> <li>Loop API \u2014 How to run code at fixed rates</li> <li>CLI Tools \u2014 Monitor, record, and launch</li> <li>Architecture \u2014 How it works under the hood</li> </ul>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Planned features for Conduit.</p>"},{"location":"roadmap/#conduit_joint","title":"conduit_joint","text":"<p>Status: Planned</p> <p>Joint is Conduit's bridge to the outside world.</p>"},{"location":"roadmap/#the-problem","title":"The Problem","text":"<p>Conduit uses shared memory \u2014 fast, but limited to one machine. Real robots need:</p> <ul> <li>Telemetry to a base station</li> <li>Commands from a remote operator</li> <li>Data to cloud services</li> <li>Integration with other systems</li> </ul>"},{"location":"roadmap/#the-solution","title":"The Solution","text":"<p>Joint provides network transports that bridge Conduit topics:</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502                        Robot                                \u2502\n\u2502                                                             \u2502\n\u2502   [Sensors] \u2192 conduit \u2192 [Joint Bridge] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502                              \u2191                           \u2502  \u2502\n\u2502   [Actuators] \u2190 conduit \u2190 [Joint Bridge] \u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502  \u2502\n\u2502                                                       \u2502  \u2502  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2518\n                                                        \u2502  \u2502\n                                            Network     \u2502  \u2502\n                                                        \u2502  \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u253c\u2500\u2500\u2510\n\u2502                    Base Station                       \u2502  \u2502  \u2502\n\u2502                                                       \u25bc  \u2502  \u2502\n\u2502   [Visualization] \u2190 [Joint Client] \u2190\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502  \u2502\n\u2502                                                          \u2502  \u2502\n\u2502   [Operator UI] \u2192 [Joint Client] \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u2502                                                             \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"roadmap/#planned-transports","title":"Planned Transports","text":"Transport Use Case TCP Reliable data over local network WebSocket Browser-based visualization UDP Low-latency telemetry (lossy OK) ZeroMQ High-performance pub/sub"},{"location":"roadmap/#configuration","title":"Configuration","text":"<pre><code># joint.yaml\nbridges:\n  - topic: camera\n    transport: tcp\n    port: 9000\n    compress: true\n\n  - topic: telemetry\n    transport: websocket\n    port: 8080\n\n  - topic: cmd_vel\n    transport: udp\n    port: 9001\n    direction: inbound\n</code></pre>"},{"location":"roadmap/#use-cases","title":"Use Cases","text":"<p>Remote visualization: <pre><code># On robot\njoint bridge --config joint.yaml\n\n# On laptop\njoint subscribe tcp://robot:9000/camera | foxglove\n</code></pre></p> <p>Teleop over network: <pre><code># Base station sends commands\njoint publish tcp://robot:9001/cmd_vel\n</code></pre></p> <p>Cloud telemetry: <pre><code># Stream to cloud service\njoint bridge --topic telemetry --to wss://cloud.example.com/ingest\n</code></pre></p>"},{"location":"roadmap/#future-ideas","title":"Future Ideas","text":"<p>These are under consideration but not yet planned:</p> Feature Description Python bindings <code>pip install conduit</code> with Pythonic API Message playback Replay MCAP files as live topics Time sync Coordinated timestamps across machines Priority topics Real-time scheduling for critical data Encryption Secure network transport Message introspection CLI tools that understand typed messages"},{"location":"roadmap/#contributing","title":"Contributing","text":"<p>Want to help? Areas where contributions are welcome:</p> <ul> <li>Testing on different Linux distributions</li> <li>Performance benchmarking</li> <li>Documentation improvements</li> <li>Bug reports and feature requests</li> </ul> <p>See the GitHub repository for issues and discussions.</p>"},{"location":"why-conduit/","title":"Why Conduit?","text":"<p>Conduit exists because ROS 2 kept getting in the way.</p>"},{"location":"why-conduit/#the-problem-with-ros-2","title":"The Problem with ROS 2","text":"<p>If you've built robots with ROS 2, you've probably experienced:</p> <p>Mysterious latency spikes. Your control loop runs fine at 100 Hz, then suddenly a frame takes 50ms instead of 10ms. You add logging, profile your code, check your algorithms - everything looks fine. The spike came from somewhere in the DDS layer, but good luck finding where.</p> <p>Unexplainable CPU usage. Your node should be sleeping, waiting for data. Instead, <code>top</code> shows 15% CPU. DDS is doing... something. Discovery? Heartbeats? Quality of Service bookkeeping? I got frustrated and never got to know what really happened \ud83e\udd37\u200d\u2642\ufe0f</p> <p>QoS settings that don't behave as documented. You set <code>reliability: reliable</code> expecting all messages to arrive. They will arrive but it will start pounding your cores. Then you got to <code>best_effort</code>, which in hindsight will not give its best effort.</p> <p>Configuration complexity. To tune DDS performance, you need XML files with dozens of parameters: <code>max_samples</code>, <code>max_instances</code>, <code>resource_limits</code>, <code>history_depth</code>, transport settings. Is it too much to ask to just send bytes from one process to another? Why do I need to learn about the intricacies of DDS and how to tune them?</p> <p>Launch file spaghetti. What started as \"just Python\" becomes unreadable nested substitutions, conditional includes, and opaque composition patterns. A simple \"start these three nodes\" becomes 200 lines. Well atleast the XML version still stayed. However, since the XML underneath calls the python API, the debugging has never been hard when a launch file crashes.</p> <p>Impossible debugging. When something goes wrong, you face layers of abstraction: your code \u2192 rclcpp \u2192 rmw \u2192 DDS implementation \u2192 network stack. By the time you find the problem, your competitor has already gotten their project done and you have lost funding.</p> <p>The fundamental issue: You spend time debugging middleware instead of building your robot.</p>"},{"location":"why-conduit/#how-conduit-is-different","title":"How Conduit is Different","text":"ROS 2 Conduit DDS with network abstraction Shared memory only Multiple QoS configurations One simple model: latest N messages XML/YAML DDS tuning files No configuration needed Python launch files Simple YAML flow files rmw \u2192 DDS \u2192 UDP/SHM Direct shared memory access Opaque latency sources You see exactly where time goes"},{"location":"why-conduit/#shared-memory-no-network-stack","title":"Shared Memory, No Network Stack","text":"<p>ROS 2's DDS abstraction was designed for distributed systems over networks. Even when communicating on the same machine, messages often go through serialization, the DDS layer, and potentially the network stack.</p> <p>Conduit uses shared memory directly:</p> <pre><code>ROS 2 (same machine):\n  Publisher \u2192 serialize \u2192 DDS \u2192 [maybe shared memory] \u2192 DDS \u2192 deserialize \u2192 Subscriber\n\nConduit:\n  Publisher \u2192 write to shared memory \u2192 Subscriber reads directly\n</code></pre> <p>One write. Zero copies to read. No serialization unless you want it.</p>"},{"location":"why-conduit/#no-configuration-needed","title":"No Configuration Needed","text":"<p>ROS 2 QoS matrix:</p> Setting Options Reliability RELIABLE, BEST_EFFORT Durability VOLATILE, TRANSIENT_LOCAL History KEEP_LAST(n), KEEP_ALL Lifespan Duration Deadline Duration Liveliness AUTOMATIC, MANUAL_BY_TOPIC <p>Conduit configuration:</p> Setting Default Slot count 16 Slot size 4 KB <p>That's it. Increase slot size for large messages. Increase slot count if you need more history.</p>"},{"location":"why-conduit/#readable-launch-files","title":"Readable Launch Files","text":"<p>ROS 2 launch file: <pre><code>from launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument, OpaqueFunction\nfrom launch.substitutions import LaunchConfiguration, PathJoinSubstitution\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    config = PathJoinSubstitution([\n        FindPackageShare('my_robot'),\n        'config',\n        'params.yaml'\n    ])\n\n    return LaunchDescription([\n        DeclareLaunchArgument('use_sim', default_value='false'),\n        Node(\n            package='my_robot',\n            executable='sensor_driver',\n            parameters=[config],\n            remappings=[('/input', '/sensors/raw')],\n            condition=UnlessCondition(LaunchConfiguration('use_sim'))\n        ),\n        # ... 150 more lines\n    ])\n</code></pre></p> <p>Conduit flow file: <pre><code>startup:\n  - sensor_driver\n  - wait: topic:sensors\n  - perception\n  - planning\n  - control\n</code></pre></p>"},{"location":"why-conduit/#predictable-latency","title":"Predictable Latency","text":"<p>ROS 2 latency sources: - DDS discovery protocol - QoS negotiation - Serialization/deserialization - Possible network stack involvement - DDS internal threading - rmw layer overhead</p> <p>Conduit latency sources: - <code>memcpy</code> into shared memory - <code>futex</code> wake system call</p> <p>Conduit is purposely designed to be invisible. When something is slow, there will be tools provided to trace the issue.</p>"},{"location":"why-conduit/#lock-free-by-design","title":"Lock-Free by Design","text":"<p>ROS 2 uses various locking mechanisms internally. A crashed or hung node can sometimes affect others through shared resources.</p> <p>Conduit's ring buffer is lock-free: - No mutexes - No deadlocks possible - Crashed publisher doesn't block subscribers - Crashed subscriber doesn't affect publisher</p>"},{"location":"why-conduit/#zero-cpu-when-idle","title":"Zero CPU When Idle","text":"<p>ROS 2's DDS implementations often have background threads for discovery, liveliness, and other bookkeeping.</p> <p>Conduit subscribers use Linux futex: - Truly asleep in the kernel - Zero CPU usage when waiting - Instant wake when data arrives</p>"},{"location":"why-conduit/#what-conduit-doesnt-do","title":"What Conduit Doesn't Do","text":"<p>Conduit is deliberately simple. It doesn't have:</p> <ul> <li>Network transport \u2014 Same-machine only (for now \u2014 see Roadmap)</li> <li>Service calls \u2014 Pub/sub only</li> <li>Parameter server \u2014 Use config files</li> <li>Lifecycle management \u2014 Nodes are just processes</li> </ul> <p>If you need distributed systems across machines, ROS 2 is the right choice. If you need a simple, fast, debuggable IPC for a single robot, Conduit gets out of your way.</p>"},{"location":"why-conduit/#when-to-use-conduit","title":"When to Use Conduit","text":"<p>\u2705 Good fit: - Single-machine robots - Latency-critical control loops - High-bandwidth sensors (cameras, LiDAR) - Teams frustrated with DDS debugging - Projects where simplicity matters</p> <p>\u274c Not a fit: - Multi-machine distributed systems - Need for ROS 2 ecosystem (Nav2, MoveIt, etc.) - Require network transport today</p>"},{"location":"api/loop/","title":"Loop","text":"<p>Run code at a fixed rate.</p>"},{"location":"api/loop/#basic-usage","title":"Basic Usage","text":"<pre><code>#include &lt;conduit_core/node.hpp&gt;\n\nclass MyNode : public conduit::Node {\npublic:\n    MyNode() {\n        loop(100.0, &amp;MyNode::control);  // 100 Hz\n    }\n\nprivate:\n    void control() {\n        // Called every 10 ms\n    }\n};\n</code></pre>"},{"location":"api/loop/#api","title":"API","text":""},{"location":"api/loop/#loop_1","title":"loop()","text":"<pre><code>template&lt;typename T, typename Func&gt;\nvoid loop(double rate_hz, Func T::* callback);\n\nvoid loop(double rate_hz, std::function&lt;void()&gt; callback);\n</code></pre> <p>Register a function to be called at a fixed rate.</p> Parameter Description <code>rate_hz</code> Frequency in Hz (e.g., 100.0 for 100 Hz) <code>callback</code> Member function or <code>std::function&lt;void()&gt;</code> <p>The loop runs in a dedicated thread. Call <code>loop()</code> in your constructor, before <code>run()</code>.</p>"},{"location":"api/loop/#how-it-works","title":"How It Works","text":"<pre><code>// Internally, each loop thread does:\nauto next_time = now();\nwhile (running) {\n    next_time += period;\n    callback();\n    sleep_until(next_time);\n}\n</code></pre> <p>Key behaviors: - Uses <code>std::chrono::steady_clock</code> for timing - Sleeps precisely to hit target rate - If callback overruns, next iteration runs immediately</p>"},{"location":"api/loop/#deadline-handling","title":"Deadline Handling","text":"<p>If your callback takes longer than the period:</p> <pre><code>Period: 10 ms (100 Hz)\nCallback takes: 15 ms\n\nIteration 1: callback() runs, takes 15 ms\n             -&gt; Missed deadline by 5 ms\n             -&gt; Warning logged\n             -&gt; Iteration 2 starts immediately\n\nIteration 2: callback() runs, takes 8 ms\n             -&gt; On time, sleeps 2 ms until next\n</code></pre> <p>A warning is logged when deadlines are missed.</p>"},{"location":"api/loop/#examples","title":"Examples","text":""},{"location":"api/loop/#control-loop","title":"Control Loop","text":"<pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_types/primitives/vec3.hpp&gt;\n#include &lt;conduit_types/derived/pose3d.hpp&gt;\n\nusing namespace conduit;\n\nclass ControlNode : public Node {\npublic:\n    ControlNode() {\n        subscribe&lt;Pose3D&gt;(\"state\", &amp;ControlNode::on_state);\n        pub_.emplace(advertise&lt;Vec3&gt;(\"cmd\"));\n        loop(100.0, &amp;ControlNode::control);  // 100 Hz control\n    }\n\nprivate:\n    void on_state(const TypedMessage&lt;Pose3D&gt;&amp; msg) {\n        std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n        latest_state_ = msg.data;\n    }\n\n    void control() {\n        Pose3D state;\n        {\n            std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n            state = latest_state_;\n        }\n\n        Vec3 cmd{};\n        cmd.x = compute_control(state);\n        pub_-&gt;publish(cmd);\n    }\n\n    std::mutex mutex_;\n    Pose3D latest_state_{};\n    std::optional&lt;Publisher&lt;Vec3&gt;&gt; pub_;\n};\n</code></pre>"},{"location":"api/loop/#multiple-loops","title":"Multiple Loops","text":"<pre><code>class MultiRateNode : public conduit::Node {\npublic:\n    MultiRateNode() {\n        loop(1000.0, &amp;MultiRateNode::fast_loop);   // 1 kHz\n        loop(100.0, &amp;MultiRateNode::medium_loop);  // 100 Hz\n        loop(10.0, &amp;MultiRateNode::slow_loop);     // 10 Hz\n    }\n\nprivate:\n    void fast_loop() {\n        // Sensor reading, 1 kHz\n    }\n\n    void medium_loop() {\n        // Control, 100 Hz\n    }\n\n    void slow_loop() {\n        // Logging/telemetry, 10 Hz\n    }\n};\n</code></pre>"},{"location":"api/loop/#publish-at-fixed-rate","title":"Publish at Fixed Rate","text":"<pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_types/primitives/uint.hpp&gt;\n\nusing namespace conduit;\n\nclass HeartbeatNode : public Node {\npublic:\n    HeartbeatNode() {\n        pub_.emplace(advertise&lt;Uint&gt;(\"heartbeat\"));\n        loop(1.0, &amp;HeartbeatNode::heartbeat);  // 1 Hz\n    }\n\nprivate:\n    void heartbeat() {\n        Uint msg{};\n        msg.value = count_++;\n        pub_-&gt;publish(msg);\n    }\n\n    std::optional&lt;Publisher&lt;Uint&gt;&gt; pub_;\n    uint64_t count_ = 0;\n};\n</code></pre>"},{"location":"api/loop/#combining-subscribe-and-loop","title":"Combining Subscribe and Loop","text":"<p>Common pattern: subscribe for input, loop for output.</p> <pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_types/derived/imu.hpp&gt;\n#include &lt;conduit_types/primitives/vec3.hpp&gt;\n\nusing namespace conduit;\n\nclass ProcessorNode : public Node {\npublic:\n    ProcessorNode() {\n        subscribe&lt;Imu&gt;(\"imu\", &amp;ProcessorNode::on_input);\n        pub_.emplace(advertise&lt;Vec3&gt;(\"filtered_accel\"));\n        loop(50.0, &amp;ProcessorNode::process);  // 50 Hz output\n    }\n\nprivate:\n    void on_input(const TypedMessage&lt;Imu&gt;&amp; msg) {\n        std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n        latest_ = msg.data;\n        has_data_ = true;\n    }\n\n    void process() {\n        Imu input;\n        {\n            std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n            if (!has_data_) return;\n            input = latest_;\n        }\n\n        Vec3 filtered{};\n        filtered.x = filter(input.linear_acceleration.x);\n        filtered.y = filter(input.linear_acceleration.y);\n        filtered.z = filter(input.linear_acceleration.z);\n        pub_-&gt;publish(filtered);\n    }\n\n    std::mutex mutex_;\n    Imu latest_{};\n    bool has_data_ = false;\n    std::optional&lt;Publisher&lt;Vec3&gt;&gt; pub_;\n};\n</code></pre>"},{"location":"api/loop/#common-rates","title":"Common Rates","text":"Use Case Typical Rate IMU reading 200-1000 Hz Motor control 100-1000 Hz Path planning 10-50 Hz Localization 10-100 Hz Telemetry/logging 1-10 Hz Watchdog/heartbeat 1 Hz"},{"location":"api/loop/#thread-safety","title":"Thread Safety","text":"<p>Each loop runs in its own thread. If you share data between: - Multiple loops - Loops and subscriptions</p> <p>Use a mutex:</p> <pre><code>std::mutex mutex_;\nVec3 shared_{};\n\nvoid on_input(const TypedMessage&lt;Vec3&gt;&amp; msg) {\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    shared_ = msg.data;\n}\n\nvoid loop_callback() {\n    std::lock_guard&lt;std::mutex&gt; lock(mutex_);\n    process(shared_);\n}\n</code></pre>"},{"location":"api/publisher/","title":"Publisher","text":"<p>Publish typed messages to a topic.</p>"},{"location":"api/publisher/#basic-usage","title":"Basic Usage","text":"<pre><code>#include &lt;conduit_core/publisher.hpp&gt;\n#include &lt;conduit_types/primitives/vec3.hpp&gt;\n\nconduit::Publisher&lt;conduit::Vec3&gt; pub(\"imu_accel\");\n\nconduit::Vec3 data{};\ndata.x = 0.1;\ndata.y = 0.0;\ndata.z = 9.81;\npub.publish(data);\n</code></pre>"},{"location":"api/publisher/#with-node","title":"With Node","text":"<p>When using the Node class, create publishers via <code>advertise&lt;T&gt;()</code>:</p> <pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_types/primitives/vec3.hpp&gt;\n\nusing namespace conduit;\n\nclass MyNode : public Node {\npublic:\n    MyNode() {\n        pub_.emplace(advertise&lt;Vec3&gt;(\"output\"));\n    }\n\nprivate:\n    void send_data() {\n        Vec3 data{};\n        data.x = 1.0;\n        pub_-&gt;publish(data);\n    }\n\n    std::optional&lt;Publisher&lt;Vec3&gt;&gt; pub_;\n};\n</code></pre>"},{"location":"api/publisher/#api","title":"API","text":""},{"location":"api/publisher/#constructor","title":"Constructor","text":"<pre><code>Publisher&lt;T&gt;(const std::string&amp; topic, const PublisherOptions&amp; options = {});\n</code></pre> <p>Creates shared memory at <code>/dev/shm/conduit_{topic}</code>.</p> <p>Only one publisher per topic. Creating a second publisher for the same topic throws an exception.</p> <p>The type <code>T</code> must be either a <code>FixedMessageType</code> or a <code>VariableMessageType</code>. This is validated at compile time.</p>"},{"location":"api/publisher/#publish","title":"publish()","text":"<pre><code>bool publish(const T&amp; msg);\n</code></pre> <p>Publishes a typed message to the topic.</p> <ul> <li>Fixed types (<code>FixedMessageType</code>): Sent via <code>memcpy</code> \u2014 zero serialization overhead.</li> <li>Variable types (<code>VariableMessageType</code>): Serialized via the type's <code>serialize()</code> method.</li> </ul> <p>Returns: <code>true</code> if published, <code>false</code> if message too large for slot.</p>"},{"location":"api/publisher/#topic","title":"topic()","text":"<pre><code>const std::string&amp; topic() const;\n</code></pre> <p>Returns the topic name.</p>"},{"location":"api/publisher/#max_message_size","title":"max_message_size()","text":"<pre><code>uint32_t max_message_size() const;\n</code></pre> <p>Returns the maximum payload size in bytes.</p>"},{"location":"api/publisher/#configuration","title":"Configuration","text":"<pre><code>conduit::PublisherOptions options;\noptions.depth = 16;              // Number of message slots (power of 2)\noptions.max_message_size = 4096; // Max payload size in bytes\n\nPublisher&lt;Vec3&gt; pub(\"camera\", options);\n</code></pre> Setting Default Description <code>depth</code> 16 How many messages to buffer <code>max_message_size</code> 4096 Max payload size in bytes <p>Choosing max_message_size:</p> <p>Your largest message must fit in this size.</p> Data Typical Size Suggested max_message_size IMU 48 bytes 4 KB (default) Pose 56 bytes 4 KB (default) Compressed image 100 KB 128 KB Point cloud 1-10 MB 12 MB Raw camera 2 MB 4 MB"},{"location":"api/publisher/#message-types","title":"Message Types","text":""},{"location":"api/publisher/#fixed-messages","title":"Fixed Messages","text":"<p>Fixed-size types sent via <code>memcpy</code>. Derive from <code>FixedMessageType</code>:</p> <pre><code>#include &lt;conduit_types/fixed_message_type.hpp&gt;\n\nstruct MyData : conduit::FixedMessageType {\n    double x;\n    double y;\n    double z;\n    uint64_t timestamp;\n};\n</code></pre> <p>Requirements: - Must be trivially copyable (no pointers, no <code>std::string</code>, no virtuals) - Must be standard layout</p> <p>See Types for built-in types.</p>"},{"location":"api/publisher/#variable-messages","title":"Variable Messages","text":"<p>Variable-size types that need serialization. Derive from <code>VariableMessageType</code>:</p> <pre><code>#include &lt;conduit_types/variable_message_type.hpp&gt;\n#include &lt;conduit_types/buffer.hpp&gt;\n\nstruct MyStringMsg : conduit::VariableMessageType {\n    std::string text;\n\n    size_t serialized_size() const override {\n        return conduit::WriteBuffer::size_of(text);\n    }\n\n    void serialize(uint8_t* buffer) const override {\n        conduit::WriteBuffer(buffer).write(text);\n    }\n\n    static MyStringMsg deserialize(const uint8_t* data, size_t size) {\n        MyStringMsg msg;\n        msg.text = conduit::ReadBuffer(data, size).read&lt;std::string&gt;();\n        return msg;\n    }\n};\n</code></pre>"},{"location":"api/publisher/#examples","title":"Examples","text":""},{"location":"api/publisher/#struct-publisher","title":"Struct Publisher","text":"<pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_types/derived/imu.hpp&gt;\n\nusing namespace conduit;\n\nclass ImuPublisher : public Node {\npublic:\n    ImuPublisher() {\n        pub_.emplace(advertise&lt;Imu&gt;(\"imu\"));\n        loop(100.0, &amp;ImuPublisher::publish);  // 100 Hz\n    }\n\nprivate:\n    void publish() {\n        Imu data{};\n        set_frame(data.header.frame, \"imu_link\");\n        data.linear_acceleration.z = 9.81;\n        pub_-&gt;publish(data);\n    }\n\n    std::optional&lt;Publisher&lt;Imu&gt;&gt; pub_;\n};\n</code></pre>"},{"location":"api/publisher/#large-message-publisher","title":"Large Message Publisher","text":"<pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_types/fixed_message_type.hpp&gt;\n\nusing namespace conduit;\n\nstruct ImageData : FixedMessageType {\n    uint8_t pixels[1920 * 1080 * 3];\n};\n\nclass CameraPublisher : public Node {\npublic:\n    CameraPublisher() {\n        PublisherOptions options;\n        options.depth = 4;\n        options.max_message_size = sizeof(ImageData);\n\n        pub_.emplace(advertise&lt;ImageData&gt;(\"camera\", options));\n        loop(30.0, &amp;CameraPublisher::publish);  // 30 FPS\n    }\n\nprivate:\n    void publish() {\n        ImageData frame{};\n        capture(frame.pixels);\n        pub_-&gt;publish(frame);\n    }\n\n    std::optional&lt;Publisher&lt;ImageData&gt;&gt; pub_;\n};\n</code></pre>"},{"location":"api/publisher/#odometry-publisher","title":"Odometry Publisher","text":"<pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_types/derived/odometry.hpp&gt;\n\nusing namespace conduit;\n\nclass OdomPublisher : public Node {\npublic:\n    OdomPublisher() {\n        pub_.emplace(advertise&lt;Odometry&gt;(\"odom\"));\n        loop(50.0, &amp;OdomPublisher::publish);\n    }\n\nprivate:\n    void publish() {\n        Odometry odom{};\n        set_frame(odom.header.frame, \"odom\");\n        set_frame(odom.child_frame, \"base_link\");\n        odom.pose.position.x = x_;\n        odom.pose.orientation = Orientation::from_yaw(theta_);\n        odom.linear_velocity.x = v_;\n        pub_-&gt;publish(odom);\n    }\n\n    std::optional&lt;Publisher&lt;Odometry&gt;&gt; pub_;\n    double x_ = 0, theta_ = 0, v_ = 0;\n};\n</code></pre>"},{"location":"api/publisher/#what-happens-when-you-publish","title":"What Happens When You Publish","text":"<ol> <li>Check message fits in slot</li> <li>Calculate slot index: <code>write_idx % slot_count</code></li> <li>Write 20-byte header (size, sequence, timestamp)</li> <li><code>memcpy</code> payload into slot (fixed types) or write serialized bytes (variable types)</li> <li>Increment <code>write_idx</code> (atomic)</li> <li>Wake all sleeping subscribers (futex)</li> </ol> <p>Total time: ~200-500 ns for small messages, dominated by <code>memcpy</code> for large ones.</p>"},{"location":"api/reference/","title":"API Reference","text":"<p>Auto-generated from Doxygen comments in the source headers.</p>"},{"location":"api/reference/#conduit_core","title":"conduit_core","text":"<p>Core pub/sub primitives: publishers, subscribers, nodes, logging, and exceptions.</p>"},{"location":"api/reference/#class-list","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace conduit <ul> <li>class ConduitError Base exception for all conduit errors. </li> <li>struct Message Raw message received from a topic. </li> <li>class Node Base class for conduit processing nodes. </li> <li>class NodeError Error in Node lifecycle (run, stop, signal handling).</li> <li>class PublisherError Error during publisher creation or publishing. </li> <li>struct PublisherOptions Configuration for topic publisher and ring buffer sizing. </li> <li>class RingBufferError Error in ring buffer operations (invalid config, overwrite detected). </li> <li>class ShmError Error during shared memory operations (create, open, map). </li> <li>class SubscriberError Error during subscriber creation or message reading. </li> <li>struct SubscriberOptions Configuration for topic subscriber. </li> <li>class TankError Error during MCAP recording (file I/O, codec failures). </li> <li>namespace internal Internal implementation details for conduit. <ul> <li>struct AlignedAtomicU64 Cache-line-aligned atomic uint64_t to prevent false sharing. </li> <li>class Publisher Low-level publisher that writes raw bytes to a shared memory ring buffer. </li> <li>struct ReadResult Result of a successful ring buffer read. </li> <li>struct RingBufferConfig Ring buffer configuration. </li> <li>struct RingBufferHeader Shared memory layout for the ring buffer control structure. </li> <li>class RingBufferReader Reader side of the lock-free SPMC ring buffer. </li> <li>class RingBufferWriter Writer side of the lock-free SPMC ring buffer. </li> <li>class ShmRegion RAII wrapper for a POSIX shared memory region. </li> <li>class Subscriber Low-level subscriber that reads raw bytes from a shared memory ring buffer. </li> </ul> </li> <li>namespace log Conduit logging utilities. </li> </ul> </li> <li>struct Loop </li> <li>struct Subscription </li> <li>class Publisher Type-safe publisher that serializes messages of type T. </li> <li>class Subscriber Type-safe subscriber that deserializes messages of type T. </li> <li>struct TypedMessage Typed message with deserialized payload. </li> <li>namespace std </li> </ul>"},{"location":"api/reference/#conduit_types","title":"conduit_types","text":"<p>Message type system: fixed-size and variable-size base classes, primitives, and derived types.</p>"},{"location":"api/reference/#class-list_1","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace conduit <ul> <li>struct Bool Fixed-size boolean message type. </li> <li>struct Double Fixed-size double-precision floating point message type. </li> <li>struct FixedMessageType Base class for fixed-size, trivially copyable message types. </li> <li>struct Header Common message header with timestamp and coordinate frame. </li> <li>struct Imu Inertial Measurement Unit data (orientation, angular velocity, linear acceleration). </li> <li>struct Int Fixed-size signed 64-bit integer message type. </li> <li>struct Odometry Odometry message with pose and velocity. </li> <li>struct Orientation Quaternion orientation (x, y, z, w) with Euler angle conversions. </li> <li>struct Pose2D 2D pose with position and orientation. </li> <li>struct Pose3D 3D pose with position and orientation. </li> <li>class ReadBuffer Sequential binary reader for deserializing message fields. </li> <li>struct Time Fixed-size timestamp message type. </li> <li>struct Twist Linear and angular velocity in 3D. </li> <li>struct Uint Fixed-size unsigned 64-bit integer message type. </li> <li>class VariableMessageType Base class for variable-size messages requiring serialization. </li> <li>struct Vec2 Fixed-size 2D vector message type. </li> <li>struct Vec3 Fixed-size 3D vector message type. </li> <li>class WriteBuffer Sequential binary writer for serializing message fields. </li> <li>namespace detail </li> </ul> </li> </ul>"},{"location":"api/reference/#conduit_tank","title":"conduit_tank","text":"<p>MCAP-based message recording with Zstd/LZ4 compression.</p>"},{"location":"api/reference/#class-list_2","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace conduit <ul> <li>class Tank MCAP-based message recorder with Zstd/LZ4 compression. </li> </ul> </li> </ul>"},{"location":"api/reference/#conduit_flow","title":"conduit_flow","text":"<p>Flow execution engine for multi-node startup and shutdown sequences.</p>"},{"location":"api/reference/#class-list_3","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace conduit <ul> <li>namespace flow <ul> <li>class Executor Executes a flow configuration (startup and shutdown sequences). </li> <li>struct ExecutorOptions Options for the flow executor. </li> <li>struct FlowConfig Complete flow configuration with startup and shutdown sequences. </li> <li>struct Group Parallel group: start multiple nodes simultaneously. </li> <li>struct NodeConfig Configuration for a single node in a flow. </li> <li>struct WaitDuration Wait step: pause for a fixed duration. </li> <li>struct WaitTopics Wait step: block until specified topics exist in shared memory. </li> </ul> </li> </ul> </li> </ul>"},{"location":"api/subscriber/","title":"Subscriber","text":"<p>Receive typed messages from a topic.</p>"},{"location":"api/subscriber/#basic-usage","title":"Basic Usage","text":"<pre><code>#include &lt;conduit_core/subscriber.hpp&gt;\n#include &lt;conduit_types/primitives/vec3.hpp&gt;\n\nconduit::Subscriber&lt;conduit::Vec3&gt; sub(\"imu_accel\");\n\nwhile (running) {\n    auto msg = sub.wait();\n    process(msg.data);  // msg.data is a Vec3\n}\n</code></pre>"},{"location":"api/subscriber/#with-node","title":"With Node","text":"<p>The preferred way \u2014 Node handles threading:</p> <pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_types/derived/imu.hpp&gt;\n\nusing namespace conduit;\n\nclass MyNode : public Node {\npublic:\n    MyNode() {\n        subscribe&lt;Imu&gt;(\"imu\", &amp;MyNode::on_imu);\n    }\n\nprivate:\n    void on_imu(const TypedMessage&lt;Imu&gt;&amp; msg) {\n        // Called in a dedicated thread for each message\n        log::info(\"Accel: [{}, {}, {}]\",\n            msg.data.linear_acceleration.x,\n            msg.data.linear_acceleration.y,\n            msg.data.linear_acceleration.z);\n    }\n};\n</code></pre> <p>Each subscription runs in its own thread. You don't manage the loop.</p>"},{"location":"api/subscriber/#api","title":"API","text":""},{"location":"api/subscriber/#constructor","title":"Constructor","text":"<pre><code>Subscriber&lt;T&gt;(const std::string&amp; topic, const SubscriberOptions&amp; options = {});\n</code></pre> <p>Opens shared memory at <code>/dev/shm/conduit_{topic}</code>.</p> <p>If the topic doesn't exist yet, the constructor waits until the publisher creates it.</p>"},{"location":"api/subscriber/#wait","title":"wait()","text":"<pre><code>TypedMessage&lt;T&gt; wait();\n</code></pre> <p>Blocks until the next message arrives. Returns a <code>TypedMessage&lt;T&gt;</code> with the deserialized data.</p> <p>This uses futex for efficient sleeping \u2014 zero CPU while waiting.</p>"},{"location":"api/subscriber/#take","title":"take()","text":"<pre><code>std::optional&lt;TypedMessage&lt;T&gt;&gt; take();\n</code></pre> <p>Non-blocking read.</p> <p>Returns: <code>TypedMessage&lt;T&gt;</code> if available, <code>std::nullopt</code> otherwise.</p> <pre><code>if (auto msg = sub.take()) {\n    process(msg-&gt;data);\n}\n</code></pre>"},{"location":"api/subscriber/#wait_for","title":"wait_for()","text":"<pre><code>std::optional&lt;TypedMessage&lt;T&gt;&gt; wait_for(std::chrono::nanoseconds timeout);\n</code></pre> <p>Blocks until a message arrives or timeout.</p> <pre><code>using namespace std::chrono_literals;\n\nif (auto msg = sub.wait_for(100ms)) {\n    process(msg-&gt;data);\n} else {\n    // Timed out\n}\n</code></pre>"},{"location":"api/subscriber/#topic","title":"topic()","text":"<pre><code>const std::string&amp; topic() const;\n</code></pre> <p>Returns the topic name.</p>"},{"location":"api/subscriber/#typedmessage","title":"TypedMessage","text":"<pre><code>template &lt;typename T&gt;\nstruct TypedMessage {\n    T data;                 // The deserialized message\n    uint64_t sequence;      // Message sequence number\n    uint64_t timestamp_ns;  // Publish timestamp (nanoseconds)\n};\n</code></pre> <p>Access the message data directly:</p> <pre><code>auto msg = sub.wait();\ndouble x = msg.data.x;          // Access fields directly\nuint64_t seq = msg.sequence;     // Sequence number\nuint64_t ts = msg.timestamp_ns;  // Timestamp\n</code></pre>"},{"location":"api/subscriber/#node-subscribe","title":"Node Subscribe","text":""},{"location":"api/subscriber/#typed-subscribe","title":"Typed Subscribe","text":"<pre><code>subscribe&lt;MsgType&gt;(\"topic\", &amp;MyNode::callback);\n</code></pre> <p>The callback receives <code>const TypedMessage&lt;MsgType&gt;&amp;</code>:</p> <pre><code>void on_imu(const TypedMessage&lt;Imu&gt;&amp; msg) {\n    Imu imu = msg.data;\n    uint64_t seq = msg.sequence;\n}\n</code></pre>"},{"location":"api/subscriber/#raw-subscribe","title":"Raw Subscribe","text":"<p>For tools and introspection, raw subscribe is still available:</p> <pre><code>subscribe(\"topic\", &amp;MyNode::callback);\n</code></pre> <p>The callback receives <code>const conduit::Message&amp;</code> with raw bytes:</p> <pre><code>void on_raw(const conduit::Message&amp; msg) {\n    const void* data = msg.data;\n    size_t size = msg.size;\n}\n</code></pre>"},{"location":"api/subscriber/#examples","title":"Examples","text":""},{"location":"api/subscriber/#typed-subscriber","title":"Typed Subscriber","text":"<pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_types/derived/odometry.hpp&gt;\n\nusing namespace conduit;\n\nclass OdomSubscriber : public Node {\npublic:\n    OdomSubscriber() {\n        subscribe&lt;Odometry&gt;(\"odom\", &amp;OdomSubscriber::on_odom);\n    }\n\nprivate:\n    void on_odom(const TypedMessage&lt;Odometry&gt;&amp; msg) {\n        const auto&amp; odom = msg.data;\n        log::info(\"Position: [{}, {}, {}] yaw: {}\",\n            odom.pose.position.x,\n            odom.pose.position.y,\n            odom.pose.position.z,\n            odom.pose.orientation.to_yaw());\n    }\n};\n</code></pre>"},{"location":"api/subscriber/#multiple-subscriptions","title":"Multiple Subscriptions","text":"<pre><code>#include &lt;conduit_core/node.hpp&gt;\n#include &lt;conduit_types/derived/imu.hpp&gt;\n#include &lt;conduit_types/derived/pose3d.hpp&gt;\n\nusing namespace conduit;\n\nclass FusionNode : public Node {\npublic:\n    FusionNode() {\n        subscribe&lt;Imu&gt;(\"imu\", &amp;FusionNode::on_imu);\n        subscribe&lt;Pose3D&gt;(\"gps_pose\", &amp;FusionNode::on_gps);\n        // Each runs in its own thread\n    }\n\nprivate:\n    void on_imu(const TypedMessage&lt;Imu&gt;&amp; msg) { /* ... */ }\n    void on_gps(const TypedMessage&lt;Pose3D&gt;&amp; msg) { /* ... */ }\n};\n</code></pre>"},{"location":"api/subscriber/#manual-loop-without-node","title":"Manual Loop (Without Node)","text":"<pre><code>#include &lt;conduit_core/subscriber.hpp&gt;\n#include &lt;conduit_types/primitives/vec3.hpp&gt;\n#include &lt;atomic&gt;\n#include &lt;signal.h&gt;\n\nstd::atomic&lt;bool&gt; running{true};\n\nvoid signal_handler(int) { running = false; }\n\nint main() {\n    signal(SIGINT, signal_handler);\n\n    conduit::Subscriber&lt;conduit::Vec3&gt; sub(\"accel\");\n\n    while (running) {\n        if (auto msg = sub.wait_for(std::chrono::milliseconds(100))) {\n            process(msg-&gt;data);\n        }\n    }\n}\n</code></pre>"},{"location":"api/subscriber/#multiple-subscribers-per-topic","title":"Multiple Subscribers Per Topic","text":"<p>Multiple processes/threads can subscribe to the same topic:</p> <pre><code>Publisher \u2192 topic \"imu\" \u2192 Subscriber A (Process 1)\n                       \u2192 Subscriber B (Process 1)\n                       \u2192 Subscriber C (Process 2)\n</code></pre> <p>Each subscriber: - Gets all messages (no load balancing) - Progresses independently - Has its own read position</p> <p>Maximum 16 subscribers per topic.</p>"},{"location":"api/subscriber/#slow-subscriber-handling","title":"Slow Subscriber Handling","text":"<p>If a subscriber can't keep up, the publisher eventually overwrites unread data:</p> <pre><code>write_idx = 100\nread_idx  = 80   &lt;- Subscriber is 20 messages behind\nslot_count = 16\n\n100 - 80 = 20 &gt; 16  &lt;- Subscriber has fallen behind!\n</code></pre> <p>When this happens: 1. Subscriber detects via sequence number mismatch 2. Subscriber skips to newest available data 3. Warning can be logged</p> <p>Solutions: - Increase <code>depth</code> in <code>PublisherOptions</code> for more buffer space - Make callback faster - Accept occasional drops (common for sensors)</p>"},{"location":"api/types/","title":"Types","text":"<p>Conduit provides a type system for messages via the <code>conduit_types</code> package.</p>"},{"location":"api/types/#message-categories","title":"Message Categories","text":""},{"location":"api/types/#fixed-messages","title":"Fixed Messages","text":"<p>Fixed-size types transported via <code>memcpy</code> with zero serialization overhead. Derive from <code>FixedMessageType</code>:</p> <pre><code>#include &lt;conduit_types/fixed_message_type.hpp&gt;\n\nstruct MyData : conduit::FixedMessageType {\n    double x;\n    double y;\n    uint32_t flags;\n};\n</code></pre> <p>Requirements:</p> <ul> <li>Trivially copyable (no pointers, <code>std::string</code>, virtual functions)</li> <li>Standard layout</li> <li>Non-empty</li> </ul> <p>All built-in primitives and derived types are fixed message types.</p>"},{"location":"api/types/#variable-messages","title":"Variable Messages","text":"<p>Variable-size types that require serialization. Derive from <code>VariableMessageType</code>:</p> <pre><code>#include &lt;conduit_types/variable_message_type.hpp&gt;\n\nstruct MyMsg : conduit::VariableMessageType {\n    std::string name;\n    std::vector&lt;double&gt; values;\n\n    size_t serialized_size() const override { /* ... */ }\n    void serialize(uint8_t* buffer) const override { /* ... */ }\n    static MyMsg deserialize(const uint8_t* data, size_t size) { /* ... */ }\n};\n</code></pre> <p>Requirements:</p> <ul> <li>Implement <code>serialized_size()</code> and <code>serialize()</code></li> <li>Provide static <code>deserialize(const uint8_t*, size_t) -&gt; T</code></li> </ul> <p>Use <code>WriteBuffer</code> and <code>ReadBuffer</code> helpers for serialization (see below).</p>"},{"location":"api/types/#primitives","title":"Primitives","text":"<p>Simple value types in <code>conduit_types/primitives/</code>.</p> Type Header Fields <code>Bool</code> <code>primitives/bool.hpp</code> <code>bool value</code> <code>Int</code> <code>primitives/int.hpp</code> <code>int64_t value</code> <code>Uint</code> <code>primitives/uint.hpp</code> <code>uint64_t value</code> <code>Double</code> <code>primitives/double.hpp</code> <code>double value</code> <code>Time</code> <code>primitives/time.hpp</code> <code>uint64_t nanoseconds</code> <code>Vec2</code> <code>primitives/vec2.hpp</code> <code>double x, y</code> <code>Vec3</code> <code>primitives/vec3.hpp</code> <code>double x, y, z</code> <pre><code>#include &lt;conduit_types/primitives/vec3.hpp&gt;\n\nconduit::Vec3 v{};\nv.x = 1.0;\nv.y = 2.0;\nv.z = 3.0;\n</code></pre>"},{"location":"api/types/#header","title":"Header","text":"<p>Most derived types include a <code>Header</code> for timestamping and frame identification:</p> <pre><code>#include &lt;conduit_types/header.hpp&gt;\n\nstruct Header {\n    uint64_t timestamp_ns;\n    char frame[64];\n};\n</code></pre> <p>Use <code>set_frame()</code> to safely set the frame string:</p> <pre><code>conduit::Imu imu{};\nconduit::set_frame(imu.header.frame, \"imu_link\");\n</code></pre>"},{"location":"api/types/#derived-types","title":"Derived Types","text":"<p>Composite types built from primitives. All include a <code>Header</code>. Located in <code>conduit_types/derived/</code>.</p>"},{"location":"api/types/#orientation","title":"Orientation","text":"<p>Quaternion orientation with Euler angle conversions.</p> <pre><code>#include &lt;conduit_types/derived/orientation.hpp&gt;\n</code></pre> Field Type <code>x</code> <code>double</code> <code>y</code> <code>double</code> <code>z</code> <code>double</code> <code>w</code> <code>double</code> <p>Conversion methods:</p> <pre><code>// Create from Euler angles (roll, pitch, yaw)\nauto q = Orientation::from_euler(roll, pitch, yaw);\nauto q = Orientation::from_euler(roll, pitch, yaw, EulerOrder::XYZ);\n\n// Create from yaw only (2D convenience)\nauto q = Orientation::from_yaw(1.57);\n\n// Convert back to Euler angles -&gt; Vec3{roll, pitch, yaw}\nVec3 euler = q.to_euler();\nVec3 euler = q.to_euler(EulerOrder::XYZ);\n\n// Extract yaw (2D convenience)\ndouble yaw = q.to_yaw();\n</code></pre> <p>Euler orders: <code>EulerOrder::ZYX</code> (default, aerospace convention) and <code>EulerOrder::XYZ</code>.</p>"},{"location":"api/types/#pose2d","title":"Pose2D","text":"<p>2D position and orientation.</p> <pre><code>#include &lt;conduit_types/derived/pose2d.hpp&gt;\n</code></pre> Field Type <code>header</code> <code>Header</code> <code>position</code> <code>Vec2</code> <code>orientation</code> <code>Orientation</code>"},{"location":"api/types/#pose3d","title":"Pose3D","text":"<p>3D position and orientation.</p> <pre><code>#include &lt;conduit_types/derived/pose3d.hpp&gt;\n</code></pre> Field Type <code>header</code> <code>Header</code> <code>position</code> <code>Vec3</code> <code>orientation</code> <code>Orientation</code>"},{"location":"api/types/#twist","title":"Twist","text":"<p>Linear and angular velocity.</p> <pre><code>#include &lt;conduit_types/derived/twist.hpp&gt;\n</code></pre> Field Type <code>header</code> <code>Header</code> <code>linear</code> <code>Vec3</code> <code>angular</code> <code>Vec3</code>"},{"location":"api/types/#imu","title":"Imu","text":"<p>Inertial measurement unit data.</p> <pre><code>#include &lt;conduit_types/derived/imu.hpp&gt;\n</code></pre> Field Type <code>header</code> <code>Header</code> <code>orientation</code> <code>Orientation</code> <code>angular_velocity</code> <code>Vec3</code> <code>linear_acceleration</code> <code>Vec3</code>"},{"location":"api/types/#odometry","title":"Odometry","text":"<p>Full odometry with pose and velocities.</p> <pre><code>#include &lt;conduit_types/derived/odometry.hpp&gt;\n</code></pre> Field Type <code>header</code> <code>Header</code> <code>child_frame</code> <code>char[64]</code> <code>pose</code> <code>Pose3D</code> <code>linear_velocity</code> <code>Vec3</code> <code>angular_velocity</code> <code>Vec3</code> <pre><code>Odometry odom{};\nset_frame(odom.header.frame, \"odom\");\nset_frame(odom.child_frame, \"base_link\");\nodom.pose.position.x = 1.0;\nodom.pose.orientation = Orientation::from_yaw(0.5);\nodom.linear_velocity.x = 1.0;\n</code></pre>"},{"location":"api/types/#serialization-helpers","title":"Serialization Helpers","text":"<p><code>WriteBuffer</code> and <code>ReadBuffer</code> simplify serialization for variable message types.</p> <pre><code>#include &lt;conduit_types/buffer.hpp&gt;\n</code></pre>"},{"location":"api/types/#writebuffer","title":"WriteBuffer","text":"<pre><code>// Calculate size\nsize_t size = WriteBuffer::size_of(my_string) + WriteBuffer::size_of(my_double);\n\n// Serialize\nWriteBuffer buf(buffer_ptr);\nbuf.write(my_string);   // writes length-prefixed string\nbuf.write(my_double);   // writes trivially copyable value\n</code></pre>"},{"location":"api/types/#readbuffer","title":"ReadBuffer","text":"<pre><code>ReadBuffer buf(data_ptr, data_size);\nauto s = buf.read&lt;std::string&gt;();   // reads length-prefixed string\nauto d = buf.read&lt;double&gt;();        // reads trivially copyable value\n</code></pre>"},{"location":"api/types/#example-custom-variable-message","title":"Example: Custom Variable Message","text":"<pre><code>#include &lt;conduit_types/variable_message_type.hpp&gt;\n#include &lt;conduit_types/buffer.hpp&gt;\n\nstruct LogEntry : conduit::VariableMessageType {\n    uint32_t level;\n    std::string message;\n\n    size_t serialized_size() const override {\n        return conduit::WriteBuffer::size_of(level)\n             + conduit::WriteBuffer::size_of(message);\n    }\n\n    void serialize(uint8_t* buffer) const override {\n        conduit::WriteBuffer buf(buffer);\n        buf.write(level);\n        buf.write(message);\n    }\n\n    static LogEntry deserialize(const uint8_t* data, size_t size) {\n        conduit::ReadBuffer buf(data, size);\n        LogEntry entry;\n        entry.level = buf.read&lt;uint32_t&gt;();\n        entry.message = buf.read&lt;std::string&gt;();\n        return entry;\n    }\n};\n</code></pre>"},{"location":"api/types/#creating-custom-types","title":"Creating Custom Types","text":""},{"location":"api/types/#fixed-type","title":"Fixed Type","text":"<pre><code>#include &lt;conduit_types/fixed_message_type.hpp&gt;\n\nstruct MotorCommand : conduit::FixedMessageType {\n    double velocity;\n    double torque;\n    uint32_t motor_id;\n};\n\n// Use it\nPublisher&lt;MotorCommand&gt; pub(\"motor_cmd\");\nMotorCommand cmd{};\ncmd.velocity = 1.5;\ncmd.torque = 0.3;\ncmd.motor_id = 1;\npub.publish(cmd);\n</code></pre>"},{"location":"api/types/#composing-built-in-types","title":"Composing Built-in Types","text":"<pre><code>#include &lt;conduit_types/fixed_message_type.hpp&gt;\n#include &lt;conduit_types/header.hpp&gt;\n#include &lt;conduit_types/primitives/vec3.hpp&gt;\n#include &lt;conduit_types/derived/orientation.hpp&gt;\n\nstruct RobotState : conduit::FixedMessageType {\n    conduit::Header header;\n    conduit::Vec3 position;\n    conduit::Orientation orientation;\n    conduit::Vec3 velocity;\n    double battery_voltage;\n};\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":"<p>This section explains how Conduit works, piece by piece.</p>"},{"location":"architecture/#the-core-idea","title":"The Core Idea","text":"<p>Imagine a whiteboard in a shared office. Anyone in the office can read it. One person writes on it.</p> <p>That's Conduit.</p> <ul> <li>The whiteboard = shared memory (a chunk of RAM both processes can access)</li> <li>The writer = publisher</li> <li>The readers = subscribers</li> </ul> <p>No photocopying. No passing notes. Everyone looks at the same whiteboard.</p>"},{"location":"architecture/#the-building-blocks","title":"The Building Blocks","text":"Part What it explains Shared Memory How two processes see the same RAM Ring Buffer How messages are stored in slots Indices How publisher and subscriber coordinate Sequence Numbers How we detect overwritten data Futex How subscribers sleep efficiently Memory Layout What the bytes actually look like <p>The elegance: All coordination happens through a few integers in shared memory. No locks. No kernel calls except when sleeping. No copies of your data.</p>"},{"location":"architecture/#code-locations","title":"Code Locations","text":"File What it does <code>src/internal/shm_region.cpp</code> Create/open/delete shared memory <code>src/internal/ring_buffer.cpp</code> Read and write to slots <code>src/internal/futex.cpp</code> Sleep and wake <code>src/internal/time.cpp</code> Get timestamps <code>src/pubsub.cpp</code> Publisher and Subscriber classes <code>src/node.cpp</code> Node with threading and signals"},{"location":"architecture/futex/","title":"Futex","text":"<p>How subscribers wait efficiently when there's no data.</p> <p></p>"},{"location":"architecture/futex/#the-problem","title":"The problem","text":"<p>Subscriber caught up, nothing to read. Three options:</p> Approach CPU Latency Busy-wait 100% Instant Sleep(10ms) ~0% Up to 10ms Futex 0% ~2-5 \u00b5s"},{"location":"architecture/futex/#how-futex-works","title":"How futex works","text":"<p>Subscriber: \"Sleep me, but only if <code>futex_word</code> is still 100.\"</p> <p>Publisher: Writes message, increments <code>futex_word</code> to 101, calls <code>futex_wake()</code>.</p> <p>Kernel: Sees 101 \u2260 100, wakes subscriber immediately.</p> <p>No missed wakeups. No race conditions.</p> <p>Next: Memory Layout \u2014 What the bytes actually look like</p>"},{"location":"architecture/indices/","title":"Write Index and Read Index","text":""},{"location":"architecture/indices/#how-it-works","title":"How it works","text":"<p>The rule: <pre><code>read_idx &lt; write_idx  \u2192  Data available, read it\nread_idx == write_idx \u2192  Caught up, wait\n</code></pre></p>"},{"location":"architecture/indices/#the-three-numbers","title":"The three numbers","text":"Name Meaning <code>write_idx</code> How many messages have been written <code>read_idx</code> Which message I want next <code>sequence</code> Which message is in this slot <p><code>write_idx = 5</code> means messages #0-#4 exist. Subscriber with <code>read_idx = 3</code> can read message #3 immediately.</p>"},{"location":"architecture/indices/#overwrites","title":"Overwrites","text":"<p>With 4 slots, message #4 overwrites slot 0 (previously held #0). The <code>sequence</code> field detects this:</p> <pre><code>Subscriber wants message #5\nSlot = 5 % 4 = slot 1\nRead slot 1 \u2192 sequence = 9\nExpected 5, got 9 \u2192 OVERWRITTEN! Skip ahead.\n</code></pre> <p>See Sequence Numbers for details.</p> <p>Next: Sequence Numbers</p>"},{"location":"architecture/memory-layout/","title":"Memory Layout","text":"<p>Each topic is a single shared memory file at <code>/dev/shm/conduit_{topic}</code>.</p> <p></p>"},{"location":"architecture/memory-layout/#structure","title":"Structure","text":"Section Contents Size Header Config + write_idx + futex_word + read_idx[16] ~1 KB Slots slot_count \u00d7 slot_size configurable"},{"location":"architecture/memory-layout/#cache-line-alignment","title":"Cache-line alignment","text":"<p>Each <code>read_idx</code> gets its own 64-byte cache line. Without this, multiple CPUs updating different subscribers would fight over the same cache line (\"false sharing\").</p>"},{"location":"architecture/memory-layout/#total-size","title":"Total size","text":"<pre><code>total = 1088 + (slot_count \u00d7 slot_size)\n</code></pre> Config Size 16 slots \u00d7 4 KB ~65 KB 4 slots \u00d7 1 MB (images) ~4 MB"},{"location":"architecture/ring-buffer/","title":"Ring Buffer","text":"<p>Fixed slots that wrap around. No memory growth, no corruption.</p>"},{"location":"architecture/ring-buffer/#how-slots-wrap","title":"How slots wrap","text":"<p>Formula: <code>slot = message_number % slot_count</code></p> <p>With 4 slots: message #0 \u2192 slot 0, message #4 \u2192 slot 0 (overwrites #0).</p>"},{"location":"architecture/ring-buffer/#slot-layout","title":"Slot layout","text":"Field Size Purpose <code>size</code> 4 bytes Payload length <code>sequence</code> 8 bytes Message number (for overwrite detection) <code>timestamp</code> 8 bytes When published (nanoseconds) <code>payload</code> remaining Your data <p>Subscriber gets: pointer to byte 20 (your data), plus size/sequence/timestamp from header.</p> <p>Next: Indices \u2014 How publisher and subscriber coordinate</p>"},{"location":"architecture/sequence/","title":"Sequence Numbers","text":"<p>How subscribers detect when they're too slow and missed messages.</p> <p></p>"},{"location":"architecture/sequence/#the-problem","title":"The problem","text":"<p>Slow subscriber wants message #90, but slot 2 now holds message #98. Reading it would give wrong data.</p>"},{"location":"architecture/sequence/#the-solution","title":"The solution","text":"<p>Each slot has a <code>sequence</code> field. Subscriber checks:</p> <pre><code>expected: 90\ngot:      98\n98 \u2260 90 \u2192 OVERWRITTEN!\n</code></pre>"},{"location":"architecture/sequence/#recovery","title":"Recovery","text":"<p>Skip to oldest available message:</p> <pre><code>oldest = write_idx - slot_count\n       = 100 - 4\n       = 96\n</code></pre> <p>Messages 90-95 are lost. Continue from 96.</p> <p>Next: Futex \u2014 How subscribers sleep efficiently</p>"},{"location":"architecture/shared-memory/","title":"Shared Memory","text":"<p>RAM that multiple processes can access. No copying between processes.</p> <p></p>"},{"location":"architecture/shared-memory/#how-it-works","title":"How it works","text":"<ol> <li>Publisher creates <code>/dev/shm/conduit_{topic}</code></li> <li>Subscriber opens the same file</li> <li>Both see the same bytes in RAM</li> </ol> <p>These aren't files on disk \u2014 they're named chunks of RAM.</p> <pre><code>$ ls /dev/shm/\nconduit_imu      # Topic \"imu\"\nconduit_camera   # Topic \"camera\"\n</code></pre> <p>Next: Ring Buffer \u2014 How messages are organized in shared memory</p>"},{"location":"conduit_core/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace conduit <ul> <li>class ConduitError Base exception for all conduit errors. </li> <li>struct Message Raw message received from a topic. </li> <li>class Node Base class for conduit processing nodes. </li> <li>class NodeError Error in Node lifecycle (run, stop, signal handling).</li> <li>class PublisherError Error during publisher creation or publishing. </li> <li>struct PublisherOptions Configuration for topic publisher and ring buffer sizing. </li> <li>class RingBufferError Error in ring buffer operations (invalid config, overwrite detected). </li> <li>class ShmError Error during shared memory operations (create, open, map). </li> <li>class SubscriberError Error during subscriber creation or message reading. </li> <li>struct SubscriberOptions Configuration for topic subscriber. </li> <li>class TankError Error during MCAP recording (file I/O, codec failures). </li> <li>namespace internal Internal implementation details for conduit. <ul> <li>struct AlignedAtomicU64 Cache-line-aligned atomic uint64_t to prevent false sharing. </li> <li>class Publisher Low-level publisher that writes raw bytes to a shared memory ring buffer. </li> <li>struct ReadResult Result of a successful ring buffer read. </li> <li>struct RingBufferConfig Ring buffer configuration. </li> <li>struct RingBufferHeader Shared memory layout for the ring buffer control structure. </li> <li>class RingBufferReader Reader side of the lock-free SPMC ring buffer. </li> <li>class RingBufferWriter Writer side of the lock-free SPMC ring buffer. </li> <li>class ShmRegion RAII wrapper for a POSIX shared memory region. </li> <li>class Subscriber Low-level subscriber that reads raw bytes from a shared memory ring buffer. </li> </ul> </li> <li>namespace log Conduit logging utilities. </li> </ul> </li> <li>struct Loop </li> <li>struct Subscription </li> <li>class Publisher Type-safe publisher that serializes messages of type T. </li> <li>class Subscriber Type-safe subscriber that deserializes messages of type T. </li> <li>struct TypedMessage Typed message with deserialized payload. </li> <li>namespace std </li> </ul>"},{"location":"conduit_core/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir packages <ul> <li>dir conduit_core <ul> <li>dir include <ul> <li>dir conduit_core <ul> <li>file exceptions.hpp </li> <li>file log.hpp </li> <li>file node.hpp </li> <li>dir internal <ul> <li>file futex.hpp </li> <li>file ring_buffer.hpp </li> <li>file shm_region.hpp </li> <li>file time.hpp </li> </ul> </li> <li>file publisher.hpp </li> <li>file subscriber.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"conduit_core/namespaceconduit/","title":"Namespace conduit","text":"<p>Namespace List &gt; conduit</p>"},{"location":"conduit_core/namespaceconduit/#namespaces","title":"Namespaces","text":"Type Name namespace internal Internal implementation details for conduit. namespace log Conduit logging utilities."},{"location":"conduit_core/namespaceconduit/#classes","title":"Classes","text":"Type Name class ConduitError Base exception for all conduit errors. struct Message Raw message received from a topic. class Node Base class for conduit processing nodes. class NodeError Error in Node lifecycle (run, stop, signal handling). class PublisherError Error during publisher creation or publishing. struct PublisherOptions Configuration for topic publisher and ring buffer sizing. class RingBufferError Error in ring buffer operations (invalid config, overwrite detected). class ShmError Error during shared memory operations (create, open, map). class SubscriberError Error during subscriber creation or message reading. struct SubscriberOptions Configuration for topic subscriber. class TankError Error during MCAP recording (file I/O, codec failures). <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/exceptions.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1ConduitError/","title":"Class conduit::ConduitError","text":"<p>ClassList &gt; conduit &gt; ConduitError</p> <p>Base exception for all conduit errors. </p> <ul> <li><code>#include &lt;exceptions.hpp&gt;</code></li> </ul> <p>Inherits the following classes: std::runtime_error</p> <p>Inherited by the following classes: conduit::NodeError,  conduit::PublisherError,  conduit::RingBufferError,  conduit::ShmError,  conduit::SubscriberError,  conduit::TankError</p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/exceptions.hpp</code></p>"},{"location":"conduit_core/structconduit_1_1Message/","title":"Struct conduit::Message","text":"<p>ClassList &gt; conduit &gt; Message</p> <p>Raw message received from a topic. More...</p> <ul> <li><code>#include &lt;subscriber.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/structconduit_1_1Message/#public-attributes","title":"Public Attributes","text":"Type Name const void * data Pointer to payload in shared memory (transient). uint64_t sequence Monotonically increasing message sequence number. size_t size Payload size in bytes. uint64_t timestamp_ns CLOCK_MONOTONIC_RAW timestamp in nanoseconds."},{"location":"conduit_core/structconduit_1_1Message/#detailed-description","title":"Detailed Description","text":"<p>Contains a pointer into shared memory that is only valid until the next call to take()/wait()/wait_for() on the same subscriber. </p>"},{"location":"conduit_core/structconduit_1_1Message/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_core/structconduit_1_1Message/#variable-data","title":"variable data","text":"<p>Pointer to payload in shared memory (transient). <pre><code>const void* conduit::Message::data;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1Message/#variable-sequence","title":"variable sequence","text":"<p>Monotonically increasing message sequence number. <pre><code>uint64_t conduit::Message::sequence;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1Message/#variable-size","title":"variable size","text":"<p>Payload size in bytes. <pre><code>size_t conduit::Message::size;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1Message/#variable-timestamp_ns","title":"variable timestamp_ns","text":"<p>CLOCK_MONOTONIC_RAW timestamp in nanoseconds. <pre><code>uint64_t conduit::Message::timestamp_ns;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/subscriber.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1Node/","title":"Class conduit::Node","text":"<p>ClassList &gt; conduit &gt; Node</p> <p>Base class for conduit processing nodes. More...</p> <ul> <li><code>#include &lt;node.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/classconduit_1_1Node/#public-functions","title":"Public Functions","text":"Type Name Node () Construct a node. Node (const Node &amp;) = delete Node (Node &amp;&amp;) = delete Node &amp; operator= (const Node &amp;) = delete Node &amp; operator= (Node &amp;&amp;) = delete void run () Run the node, blocking until SIGINT/SIGTERM or stop() is called. bool running () constCheck if the node is currently running. void stop () Stop the node (can be called from any thread or signal handler). virtual ~Node ()"},{"location":"conduit_core/classconduit_1_1Node/#protected-functions","title":"Protected Functions","text":"Type Name Publisher&lt; T &gt; advertise (const std::string &amp; topic, const PublisherOptions &amp; options={}) Create a typed publisher for the given topic. void loop (double rate_hz, Func T::* callback) Register a fixed-rate loop with a member function callback. void loop (double rate_hz, std::function&lt; void()&gt; callback) Register a fixed-rate loop with a lambda or std::function callback. void subscribe (const std::string &amp; topic, Func T::* callback) Subscribe to a topic with a member function callback (raw). void subscribe (const std::string &amp; topic, void(T::*)(const TypedMessage&lt; MsgT &gt; &amp;) callback) Subscribe to a topic with a typed member function callback. void subscribe (const std::string &amp; topic, std::function&lt; void(const Message &amp;)&gt; callback) Subscribe to a topic with a lambda or std::function callback (raw)."},{"location":"conduit_core/classconduit_1_1Node/#detailed-description","title":"Detailed Description","text":"<p>A Node manages subscriptions and publish loops. Each subscription runs on its own thread, with callbacks dispatched automatically when messages arrive. Call run() to start all threads and block until SIGINT/SIGTERM or stop() is called.</p> <pre><code>class MyNode : public conduit::Node {\npublic:\n    MyNode() {\n        subscribe&lt;Imu&gt;(\"imu\", &amp;MyNode::on_imu);\n        pub_ = advertise&lt;Twist&gt;(\"cmd_vel\");\n        loop(10.0, &amp;MyNode::tick);\n    }\nprivate:\n    void on_imu(const TypedMessage&lt;Imu&gt;&amp; msg) { /* ... */ }\n    void tick() { pub_.publish(Twist{}); }\n    Publisher&lt;Twist&gt; pub_;\n};\n</code></pre> <p>See also: Publisher, Subscriber </p>"},{"location":"conduit_core/classconduit_1_1Node/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_core/classconduit_1_1Node/#function-node-13","title":"function Node [1/3]","text":"<p>Construct a node. <pre><code>conduit::Node::Node () \n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1Node/#function-node-23","title":"function Node [2/3]","text":"<pre><code>conduit::Node::Node (\n    const Node &amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1Node/#function-node-33","title":"function Node [3/3]","text":"<pre><code>conduit::Node::Node (\n    Node &amp;&amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1Node/#function-operator","title":"function operator=","text":"<pre><code>Node &amp; conduit::Node::operator= (\n    const Node &amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1Node/#function-operator_1","title":"function operator=","text":"<pre><code>Node &amp; conduit::Node::operator= (\n    Node &amp;&amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1Node/#function-run","title":"function run","text":"<p>Run the node, blocking until SIGINT/SIGTERM or stop() is called. <pre><code>void conduit::Node::run () \n</code></pre></p> <p>Starts all subscription threads and loop threads, installs signal handlers, and blocks the calling thread. </p>"},{"location":"conduit_core/classconduit_1_1Node/#function-running","title":"function running","text":"<p>Check if the node is currently running. <pre><code>bool conduit::Node::running () const\n</code></pre></p> <p>Returns:</p> <p>true if run() has been called and stop() has not yet completed. </p>"},{"location":"conduit_core/classconduit_1_1Node/#function-stop","title":"function stop","text":"<p>Stop the node (can be called from any thread or signal handler). <pre><code>void conduit::Node::stop () \n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1Node/#function-node","title":"function ~Node","text":"<pre><code>virtual conduit::Node::~Node () \n</code></pre>"},{"location":"conduit_core/classconduit_1_1Node/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"conduit_core/classconduit_1_1Node/#function-advertise","title":"function advertise","text":"<p>Create a typed publisher for the given topic. <pre><code>template&lt;typename T&gt;\nPublisher&lt; T &gt; conduit::Node::advertise (\n    const std::string &amp; topic,\n    const PublisherOptions &amp; options={}\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> Message type to publish. </li> </ul> <p>Parameters:</p> <ul> <li><code>topic</code> Topic name. </li> <li><code>options</code> Publisher configuration. </li> </ul> <p>Returns:</p> <p>A Publisher&lt;T&gt; ready to publish messages. </p>"},{"location":"conduit_core/classconduit_1_1Node/#function-loop-12","title":"function loop [1/2]","text":"<p>Register a fixed-rate loop with a member function callback. <pre><code>template&lt;typename T, typename Func&gt;\nvoid conduit::Node::loop (\n    double rate_hz,\n    Func T::* callback\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> Derived Node type. </li> <li><code>Func</code> Member function pointer type. </li> </ul> <p>Parameters:</p> <ul> <li><code>rate_hz</code> Loop frequency in Hz. </li> <li><code>callback</code> Member function to call each iteration. </li> </ul>"},{"location":"conduit_core/classconduit_1_1Node/#function-loop-22","title":"function loop [2/2]","text":"<p>Register a fixed-rate loop with a lambda or std::function callback. <pre><code>void conduit::Node::loop (\n    double rate_hz,\n    std::function&lt; void()&gt; callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>rate_hz</code> Loop frequency in Hz. </li> <li><code>callback</code> Function to call each iteration. </li> </ul>"},{"location":"conduit_core/classconduit_1_1Node/#function-subscribe-13","title":"function subscribe [1/3]","text":"<p>Subscribe to a topic with a member function callback (raw). <pre><code>template&lt;typename T, typename Func&gt;\nvoid conduit::Node::subscribe (\n    const std::string &amp; topic,\n    Func T::* callback\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> Derived Node type. </li> <li><code>Func</code> Member function pointer type. </li> </ul> <p>Parameters:</p> <ul> <li><code>topic</code> Topic name to subscribe to. </li> <li><code>callback</code> Member function to call on each message. </li> </ul>"},{"location":"conduit_core/classconduit_1_1Node/#function-subscribe-23","title":"function subscribe [2/3]","text":"<p>Subscribe to a topic with a typed member function callback. <pre><code>template&lt;typename MsgT, typename T&gt;\nvoid conduit::Node::subscribe (\n    const std::string &amp; topic,\n    void(T::*)(const TypedMessage&lt; MsgT &gt; &amp;) callback\n) \n</code></pre></p> <p>Messages are automatically deserialized to MsgT before invoking the callback.</p> <p>Template parameters:</p> <ul> <li><code>MsgT</code> Message type to deserialize into. </li> <li><code>T</code> Derived Node type. </li> </ul> <p>Parameters:</p> <ul> <li><code>topic</code> Topic name to subscribe to. </li> <li><code>callback</code> Member function receiving TypedMessage&lt;MsgT&gt;. </li> </ul>"},{"location":"conduit_core/classconduit_1_1Node/#function-subscribe-33","title":"function subscribe [3/3]","text":"<p>Subscribe to a topic with a lambda or std::function callback (raw). <pre><code>void conduit::Node::subscribe (\n    const std::string &amp; topic,\n    std::function&lt; void(const Message &amp;)&gt; callback\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>topic</code> Topic name to subscribe to. </li> <li><code>callback</code> Function invoked with each raw Message. </li> </ul> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/node.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1NodeError/","title":"Class conduit::NodeError","text":"<p>ClassList &gt; conduit &gt; NodeError</p> <p>Error in Node lifecycle (run, stop, signal handling).</p> <ul> <li><code>#include &lt;exceptions.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::ConduitError</p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/exceptions.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1PublisherError/","title":"Class conduit::PublisherError","text":"<p>ClassList &gt; conduit &gt; PublisherError</p> <p>Error during publisher creation or publishing. </p> <ul> <li><code>#include &lt;exceptions.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::ConduitError</p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/exceptions.hpp</code></p>"},{"location":"conduit_core/structconduit_1_1PublisherOptions/","title":"Struct conduit::PublisherOptions","text":"<p>ClassList &gt; conduit &gt; PublisherOptions</p> <p>Configuration for topic publisher and ring buffer sizing. </p> <ul> <li><code>#include &lt;publisher.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/structconduit_1_1PublisherOptions/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t depth   = <code>16</code>Number of message slots in the ring buffer (must be power of 2). uint32_t max_message_size   = <code>4096</code>Maximum payload size in bytes. Messages exceeding this are rejected."},{"location":"conduit_core/structconduit_1_1PublisherOptions/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_core/structconduit_1_1PublisherOptions/#variable-depth","title":"variable depth","text":"<p>Number of message slots in the ring buffer (must be power of 2). <pre><code>uint32_t conduit::PublisherOptions::depth;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1PublisherOptions/#variable-max_message_size","title":"variable max_message_size","text":"<p>Maximum payload size in bytes. Messages exceeding this are rejected. <pre><code>uint32_t conduit::PublisherOptions::max_message_size;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/publisher.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1RingBufferError/","title":"Class conduit::RingBufferError","text":"<p>ClassList &gt; conduit &gt; RingBufferError</p> <p>Error in ring buffer operations (invalid config, overwrite detected). </p> <ul> <li><code>#include &lt;exceptions.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::ConduitError</p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/exceptions.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1ShmError/","title":"Class conduit::ShmError","text":"<p>ClassList &gt; conduit &gt; ShmError</p> <p>Error during shared memory operations (create, open, map). </p> <ul> <li><code>#include &lt;exceptions.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::ConduitError</p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/exceptions.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1SubscriberError/","title":"Class conduit::SubscriberError","text":"<p>ClassList &gt; conduit &gt; SubscriberError</p> <p>Error during subscriber creation or message reading. </p> <ul> <li><code>#include &lt;exceptions.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::ConduitError</p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/exceptions.hpp</code></p>"},{"location":"conduit_core/structconduit_1_1SubscriberOptions/","title":"Struct conduit::SubscriberOptions","text":"<p>ClassList &gt; conduit &gt; SubscriberOptions</p> <p>Configuration for topic subscriber. </p> <ul> <li><code>#include &lt;subscriber.hpp&gt;</code></li> </ul> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/subscriber.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1TankError/","title":"Class conduit::TankError","text":"<p>ClassList &gt; conduit &gt; TankError</p> <p>Error during MCAP recording (file I/O, codec failures). </p> <ul> <li><code>#include &lt;exceptions.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::ConduitError</p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/exceptions.hpp</code></p>"},{"location":"conduit_core/namespaceconduit_1_1internal/","title":"Namespace conduit::internal","text":"<p>Namespace List &gt; conduit &gt; internal</p> <p>Internal implementation details for conduit. </p>"},{"location":"conduit_core/namespaceconduit_1_1internal/#classes","title":"Classes","text":"Type Name struct AlignedAtomicU64 Cache-line-aligned atomic uint64_t to prevent false sharing. class Publisher Low-level publisher that writes raw bytes to a shared memory ring buffer. struct ReadResult Result of a successful ring buffer read. struct RingBufferConfig Ring buffer configuration. struct RingBufferHeader Shared memory layout for the ring buffer control structure. class RingBufferReader Reader side of the lock-free SPMC ring buffer. class RingBufferWriter Writer side of the lock-free SPMC ring buffer. class ShmRegion RAII wrapper for a POSIX shared memory region. class Subscriber Low-level subscriber that reads raw bytes from a shared memory ring buffer."},{"location":"conduit_core/namespaceconduit_1_1internal/#public-attributes","title":"Public Attributes","text":"Type Name constexpr size_t CACHE_LINE_SIZE   = <code>64</code>CPU cache line size used for alignment to prevent false sharing. constexpr size_t MAX_SUBSCRIBERS   = <code>16</code>Maximum number of concurrent subscriber reader slots. constexpr size_t SLOT_HEADER_SIZE   = <code>[**sizeof**](classconduit_1_1internal_1_1Publisher.md)([**uint32\\_t**](classconduit_1_1internal_1_1Publisher.md)) + [**sizeof**](classconduit_1_1internal_1_1Publisher.md)([**uint64\\_t**](classconduit_1_1internal_1_1Publisher.md)) + [**sizeof**](classconduit_1_1internal_1_1Publisher.md)([**uint64\\_t**](classconduit_1_1internal_1_1Publisher.md))</code>Size of each slot's header in bytes."},{"location":"conduit_core/namespaceconduit_1_1internal/#public-functions","title":"Public Functions","text":"Type Name size_t calculate_region_size (const RingBufferConfig &amp; config) Calculate total shared memory region size for the given config. bool futex_wait (std::atomic&lt; uint32_t &gt; * futex_word, uint32_t expected_value, std::optional&lt; std::chrono::nanoseconds &gt; timeout=std::nullopt) Wait until the futex word changes from the expected value. int futex_wake (std::atomic&lt; uint32_t &gt; * futex_word, int count=1) Wake up to <code>count</code> threads waiting on the futex word. int futex_wake_all (std::atomic&lt; uint32_t &gt; * futex_word) Wake all threads waiting on the futex word. uint64_t get_timestamp_ns () Get the current timestamp in nanoseconds from CLOCK_MONOTONIC_RAW. bool is_power_of_two (uint32_t n) Check if n is a power of two."},{"location":"conduit_core/namespaceconduit_1_1internal/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_core/namespaceconduit_1_1internal/#variable-cache_line_size","title":"variable CACHE_LINE_SIZE","text":"<p>CPU cache line size used for alignment to prevent false sharing. <pre><code>constexpr size_t conduit::internal::CACHE_LINE_SIZE;\n</code></pre></p>"},{"location":"conduit_core/namespaceconduit_1_1internal/#variable-max_subscribers","title":"variable MAX_SUBSCRIBERS","text":"<p>Maximum number of concurrent subscriber reader slots. <pre><code>constexpr size_t conduit::internal::MAX_SUBSCRIBERS;\n</code></pre></p>"},{"location":"conduit_core/namespaceconduit_1_1internal/#variable-slot_header_size","title":"variable SLOT_HEADER_SIZE","text":"<p>Size of each slot's header in bytes. <pre><code>constexpr size_t conduit::internal::SLOT_HEADER_SIZE;\n</code></pre></p> <p>Slot header layout:  <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 size (4B)  \u2502 sequence (8B)\u2502 timestamp (8B)  \u2502  = 20 bytes\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre></p>"},{"location":"conduit_core/namespaceconduit_1_1internal/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_core/namespaceconduit_1_1internal/#function-calculate_region_size","title":"function calculate_region_size","text":"<p>Calculate total shared memory region size for the given config. <pre><code>inline size_t conduit::internal::calculate_region_size (\n    const  RingBufferConfig &amp; config\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>config</code> Ring buffer configuration. </li> </ul> <p>Returns:</p> <p>Total size in bytes (header + all slots). </p>"},{"location":"conduit_core/namespaceconduit_1_1internal/#function-futex_wait","title":"function futex_wait","text":"<p>Wait until the futex word changes from the expected value. <pre><code>bool conduit::internal::futex_wait (\n    std::atomic&lt; uint32_t &gt; * futex_word,\n    uint32_t expected_value,\n    std::optional&lt; std::chrono::nanoseconds &gt; timeout=std::nullopt\n) \n</code></pre></p> <p>Wraps the Linux <code>futex(FUTEX_WAIT)</code> syscall. The calling thread sleeps (consuming zero CPU) until another thread calls futex_wake() on the same word, or the optional timeout expires. A spurious wakeup is possible if the futex word has already changed by the time the syscall executes.</p> <p>Parameters:</p> <ul> <li><code>futex_word</code> Pointer to the atomic futex word in shared memory. </li> <li><code>expected_value</code> The value that triggered the wait; if the current value differs, the call returns immediately. </li> <li><code>timeout</code> Optional maximum wait duration. std::nullopt means wait forever. </li> </ul> <p>Returns:</p> <p>true if woken by futex_wake(), false on timeout. </p>"},{"location":"conduit_core/namespaceconduit_1_1internal/#function-futex_wake","title":"function futex_wake","text":"<p>Wake up to <code>count</code> threads waiting on the futex word. <pre><code>int conduit::internal::futex_wake (\n    std::atomic&lt; uint32_t &gt; * futex_word,\n    int count=1\n) \n</code></pre></p> <p>Wraps the Linux <code>futex(FUTEX_WAKE)</code> syscall.</p> <p>Parameters:</p> <ul> <li><code>futex_word</code> Pointer to the atomic futex word. </li> <li><code>count</code> Maximum number of waiters to wake (default 1). </li> </ul> <p>Returns:</p> <p>Number of waiters actually woken. </p>"},{"location":"conduit_core/namespaceconduit_1_1internal/#function-futex_wake_all","title":"function futex_wake_all","text":"<p>Wake all threads waiting on the futex word. <pre><code>int conduit::internal::futex_wake_all (\n    std::atomic&lt; uint32_t &gt; * futex_word\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>futex_word</code> Pointer to the atomic futex word. </li> </ul> <p>Returns:</p> <p>Number of waiters actually woken. </p>"},{"location":"conduit_core/namespaceconduit_1_1internal/#function-get_timestamp_ns","title":"function get_timestamp_ns","text":"<p>Get the current timestamp in nanoseconds from CLOCK_MONOTONIC_RAW. <pre><code>uint64_t conduit::internal::get_timestamp_ns () \n</code></pre></p> <p>Returns:</p> <p>Nanoseconds since an arbitrary epoch (monotonic, not wall-clock). </p>"},{"location":"conduit_core/namespaceconduit_1_1internal/#function-is_power_of_two","title":"function is_power_of_two","text":"<p>Check if n is a power of two. <pre><code>inline bool conduit::internal::is_power_of_two (\n    uint32_t n\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>n</code> Value to check. </li> </ul> <p>Returns:</p> <p>true if n is a power of two. </p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/futex.hpp</code></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1AlignedAtomicU64/","title":"Struct conduit::internal::AlignedAtomicU64","text":"<p>ClassList &gt; conduit &gt; internal &gt; AlignedAtomicU64</p> <p>Cache-line-aligned atomic uint64_t to prevent false sharing. </p> <ul> <li><code>#include &lt;ring_buffer.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/structconduit_1_1internal_1_1AlignedAtomicU64/#public-attributes","title":"Public Attributes","text":"Type Name std::atomic&lt; uint64_t &gt; value"},{"location":"conduit_core/structconduit_1_1internal_1_1AlignedAtomicU64/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_core/structconduit_1_1internal_1_1AlignedAtomicU64/#variable-value","title":"variable value","text":"<pre><code>std::atomic&lt;uint64_t&gt; conduit::internal::AlignedAtomicU64::value;\n</code></pre> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/ring_buffer.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/","title":"Class conduit::internal::Publisher","text":"<p>ClassList &gt; conduit &gt; internal &gt; Publisher</p> <p>Low-level publisher that writes raw bytes to a shared memory ring buffer. More...</p> <ul> <li><code>#include &lt;publisher.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/#public-functions","title":"Public Functions","text":"Type Name Publisher (const std::string &amp; topic, const PublisherOptions &amp; options={}) Construct a publisher for the given topic. Publisher (Publisher &amp;&amp;) noexceptMove constructor. Publisher (const Publisher &amp;) = delete uint32_t max_message_size () constGet the maximum allowed message size. Publisher &amp; operator= (Publisher &amp;&amp;) noexceptMove assignment operator. Publisher &amp; operator= (const Publisher &amp;) = delete bool publish (const void * data, size_t size) Publish raw data to the topic. const std::string &amp; topic () constGet the topic name. ~Publisher ()"},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/#detailed-description","title":"Detailed Description","text":"<p>Creates a shared memory region at <code>/dev/shm/conduit_{topic}</code> and manages a lock-free SPMC ring buffer for zero-copy message delivery. Use the typed Publisher&lt;T&gt; wrapper for type-safe publishing.</p> <p>See also: conduit::Publisher </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/#function-publisher-13","title":"function Publisher [1/3]","text":"<p>Construct a publisher for the given topic. <pre><code>conduit::internal::Publisher::Publisher (\n    const std::string &amp; topic,\n    const  PublisherOptions &amp; options={}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>topic</code> Topic name used to create the shared memory region. </li> <li><code>options</code> Ring buffer configuration (depth and max message size). </li> </ul> <p>Exception:</p> <ul> <li>PublisherError If shared memory creation fails. </li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/#function-publisher-23","title":"function Publisher [2/3]","text":"<p>Move constructor. <pre><code>conduit::internal::Publisher::Publisher (\n    Publisher &amp;&amp;\n) noexcept\n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/#function-publisher-33","title":"function Publisher [3/3]","text":"<pre><code>conduit::internal::Publisher::Publisher (\n    const  Publisher &amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/#function-max_message_size","title":"function max_message_size","text":"<p>Get the maximum allowed message size. <pre><code>inline uint32_t conduit::internal::Publisher::max_message_size () const\n</code></pre></p> <p>Returns:</p> <p>Maximum payload size in bytes. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/#function-operator","title":"function operator=","text":"<p>Move assignment operator. <pre><code>Publisher &amp; conduit::internal::Publisher::operator= (\n    Publisher &amp;&amp;\n) noexcept\n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/#function-operator_1","title":"function operator=","text":"<pre><code>Publisher &amp; conduit::internal::Publisher::operator= (\n    const  Publisher &amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/#function-publish","title":"function publish","text":"<p>Publish raw data to the topic. <pre><code>bool conduit::internal::Publisher::publish (\n    const  void * data,\n    size_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>data</code> Pointer to the payload bytes. </li> <li><code>size</code> Size of the payload in bytes. </li> </ul> <p>Returns:</p> <p>true if the message was written, false if size exceeds max_message_size. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/#function-topic","title":"function topic","text":"<p>Get the topic name. <pre><code>inline const std::string &amp; conduit::internal::Publisher::topic () const\n</code></pre></p> <p>Returns:</p> <p>Reference to the topic string. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Publisher/#function-publisher","title":"function ~Publisher","text":"<pre><code>conduit::internal::Publisher::~Publisher () \n</code></pre> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/publisher.hpp</code></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1ReadResult/","title":"Struct conduit::internal::ReadResult","text":"<p>ClassList &gt; conduit &gt; internal &gt; ReadResult</p> <p>Result of a successful ring buffer read. </p> <ul> <li><code>#include &lt;ring_buffer.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/structconduit_1_1internal_1_1ReadResult/#public-attributes","title":"Public Attributes","text":"Type Name const void * data Pointer to payload within the slot. uint64_t sequence Message sequence number. size_t size Payload size in bytes. uint64_t timestamp_ns CLOCK_MONOTONIC_RAW timestamp in nanoseconds."},{"location":"conduit_core/structconduit_1_1internal_1_1ReadResult/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_core/structconduit_1_1internal_1_1ReadResult/#variable-data","title":"variable data","text":"<p>Pointer to payload within the slot. <pre><code>const void* conduit::internal::ReadResult::data;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1ReadResult/#variable-sequence","title":"variable sequence","text":"<p>Message sequence number. <pre><code>uint64_t conduit::internal::ReadResult::sequence;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1ReadResult/#variable-size","title":"variable size","text":"<p>Payload size in bytes. <pre><code>size_t conduit::internal::ReadResult::size;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1ReadResult/#variable-timestamp_ns","title":"variable timestamp_ns","text":"<p>CLOCK_MONOTONIC_RAW timestamp in nanoseconds. <pre><code>uint64_t conduit::internal::ReadResult::timestamp_ns;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/ring_buffer.hpp</code></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferConfig/","title":"Struct conduit::internal::RingBufferConfig","text":"<p>ClassList &gt; conduit &gt; internal &gt; RingBufferConfig</p> <p>Ring buffer configuration. </p> <ul> <li><code>#include &lt;ring_buffer.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferConfig/#public-attributes","title":"Public Attributes","text":"Type Name uint32_t slot_count Number of slots (must be power of 2). uint32_t slot_size Bytes per slot (including slot header)."},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferConfig/#variable-slot_count","title":"variable slot_count","text":"<p>Number of slots (must be power of 2). <pre><code>uint32_t conduit::internal::RingBufferConfig::slot_count;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferConfig/#variable-slot_size","title":"variable slot_size","text":"<p>Bytes per slot (including slot header). <pre><code>uint32_t conduit::internal::RingBufferConfig::slot_size;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/ring_buffer.hpp</code></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferHeader/","title":"Struct conduit::internal::RingBufferHeader","text":"<p>ClassList &gt; conduit &gt; internal &gt; RingBufferHeader</p> <p>Shared memory layout for the ring buffer control structure. More...</p> <ul> <li><code>#include &lt;ring_buffer.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferHeader/#public-attributes","title":"Public Attributes","text":"Type Name std::atomic&lt; uint32_t &gt; futex_word Futex word used for subscriber wake signaling. uint32_t max_subscribers Maximum reader slots. uint32_t padding0 Padding for alignment. AlignedAtomicU64 read_idx Per-reader current read index (each on own cache line). uint32_t slot_count Number of slots. uint32_t slot_size Bytes per slot. std::atomic&lt; uint32_t &gt; subscriber_mask Bitmask of claimed subscriber slots (own cache line). std::atomic&lt; uint64_t &gt; write_idx Writer's next write index (own cache line to avoid false sharing)."},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferHeader/#detailed-description","title":"Detailed Description","text":"<p>Resides at the start of the shared memory region, followed by the slot data array. Each field group is cache-line-aligned to prevent false sharing between the writer and readers.</p> <pre><code>Shared Memory Layout:\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  offset 0\n\u2502  RingBufferHeader                      \u2502\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502\n\u2502  \u2502 config (immutable after init)    \u2502  \u2502\n\u2502  \u2502  slot_count, slot_size, etc.     \u2502  \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502  aligned 64B\n\u2502  \u2502 write_idx (writer only)          \u2502  \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502  aligned 64B\n\u2502  \u2502 subscriber_mask + futex_word     \u2502  \u2502\n\u2502  \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524  \u2502  aligned 64B\n\u2502  \u2502 read_idx[0..MAX_SUBSCRIBERS-1]   \u2502  \u2502  each aligned 64B\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2502\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n\u2502  Slot[0]: [hdr 20B | payload ...]     \u2502\n\u2502  Slot[1]: [hdr 20B | payload ...]     \u2502\n\u2502  ...                                   \u2502\n\u2502  Slot[N-1]: [hdr 20B | payload ...]   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferHeader/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferHeader/#variable-futex_word","title":"variable futex_word","text":"<p>Futex word used for subscriber wake signaling. <pre><code>std::atomic&lt;uint32_t&gt; conduit::internal::RingBufferHeader::futex_word;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferHeader/#variable-max_subscribers","title":"variable max_subscribers","text":"<p>Maximum reader slots. <pre><code>uint32_t conduit::internal::RingBufferHeader::max_subscribers;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferHeader/#variable-padding0","title":"variable padding0","text":"<p>Padding for alignment. <pre><code>uint32_t conduit::internal::RingBufferHeader::padding0;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferHeader/#variable-read_idx","title":"variable read_idx","text":"<p>Per-reader current read index (each on own cache line). <pre><code>AlignedAtomicU64 conduit::internal::RingBufferHeader::read_idx[MAX_SUBSCRIBERS];\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferHeader/#variable-slot_count","title":"variable slot_count","text":"<p>Number of slots. <pre><code>uint32_t conduit::internal::RingBufferHeader::slot_count;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferHeader/#variable-slot_size","title":"variable slot_size","text":"<p>Bytes per slot. <pre><code>uint32_t conduit::internal::RingBufferHeader::slot_size;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferHeader/#variable-subscriber_mask","title":"variable subscriber_mask","text":"<p>Bitmask of claimed subscriber slots (own cache line). <pre><code>std::atomic&lt;uint32_t&gt; conduit::internal::RingBufferHeader::subscriber_mask;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1internal_1_1RingBufferHeader/#variable-write_idx","title":"variable write_idx","text":"<p>Writer's next write index (own cache line to avoid false sharing). <pre><code>std::atomic&lt;uint64_t&gt; conduit::internal::RingBufferHeader::write_idx;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/ring_buffer.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferReader/","title":"Class conduit::internal::RingBufferReader","text":"<p>ClassList &gt; conduit &gt; internal &gt; RingBufferReader</p> <p>Reader side of the lock-free SPMC ring buffer. More...</p> <ul> <li><code>#include &lt;ring_buffer.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferReader/#public-functions","title":"Public Functions","text":"Type Name RingBufferReader (void * region, size_t region_size) Construct a reader over an existing shared memory region. int claim_slot () Claim a subscriber slot in the ring buffer. RingBufferHeader * header () Access the ring buffer header. void release_slot (int slot) Release a previously claimed subscriber slot. std::optional&lt; ReadResult &gt; try_read (int slot) Non-blocking read of the next message. std::optional&lt; ReadResult &gt; wait (int slot) Block until a message is available (waits forever). std::optional&lt; ReadResult &gt; wait_for (int slot, std::chrono::nanoseconds timeout) Block until a message is available or timeout expires."},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferReader/#detailed-description","title":"Detailed Description","text":"<p>Multiple readers can exist per topic (up to MAX_SUBSCRIBERS). Each reader claims a slot via claim_slot(), then reads messages independently. If the writer laps a reader, the reader detects the overwrite via sequence number validation and skips ahead.</p> <p>See also: RingBufferWriter </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferReader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferReader/#function-ringbufferreader","title":"function RingBufferReader","text":"<p>Construct a reader over an existing shared memory region. <pre><code>conduit::internal::RingBufferReader::RingBufferReader (\n    void * region,\n    size_t region_size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>region</code> Pointer to the shared memory region (must already be initialized). </li> <li><code>region_size</code> Total size of the region in bytes. </li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferReader/#function-claim_slot","title":"function claim_slot","text":"<p>Claim a subscriber slot in the ring buffer. <pre><code>int conduit::internal::RingBufferReader::claim_slot () \n</code></pre></p> <p>Returns:</p> <p>Slot index (0..MAX_SUBSCRIBERS-1), or -1 if all slots are taken. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferReader/#function-header","title":"function header","text":"<p>Access the ring buffer header. <pre><code>inline RingBufferHeader * conduit::internal::RingBufferReader::header () \n</code></pre></p> <p>Returns:</p> <p>Pointer to the header in shared memory. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferReader/#function-release_slot","title":"function release_slot","text":"<p>Release a previously claimed subscriber slot. <pre><code>void conduit::internal::RingBufferReader::release_slot (\n    int slot\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>slot</code> Slot index to release. </li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferReader/#function-try_read","title":"function try_read","text":"<p>Non-blocking read of the next message. <pre><code>std::optional&lt; ReadResult &gt; conduit::internal::RingBufferReader::try_read (\n    int slot\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>slot</code> Reader slot index from claim_slot(). </li> </ul> <p>Returns:</p> <p>The next message, or std::nullopt if no new message is available. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferReader/#function-wait","title":"function wait","text":"<p>Block until a message is available (waits forever). <pre><code>std::optional&lt; ReadResult &gt; conduit::internal::RingBufferReader::wait (\n    int slot\n) \n</code></pre></p> <p>Uses futex-based signaling for zero CPU usage while idle.</p> <p>Parameters:</p> <ul> <li><code>slot</code> Reader slot index. </li> </ul> <p>Returns:</p> <p>The next message, or std::nullopt on spurious wakeup. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferReader/#function-wait_for","title":"function wait_for","text":"<p>Block until a message is available or timeout expires. <pre><code>std::optional&lt; ReadResult &gt; conduit::internal::RingBufferReader::wait_for (\n    int slot,\n    std::chrono::nanoseconds timeout\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>slot</code> Reader slot index. </li> <li><code>timeout</code> Maximum time to wait. </li> </ul> <p>Returns:</p> <p>The next message, or std::nullopt on timeout. </p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/ring_buffer.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferWriter/","title":"Class conduit::internal::RingBufferWriter","text":"<p>ClassList &gt; conduit &gt; internal &gt; RingBufferWriter</p> <p>Writer side of the lock-free SPMC ring buffer. More...</p> <ul> <li><code>#include &lt;ring_buffer.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferWriter/#public-functions","title":"Public Functions","text":"Type Name RingBufferWriter (void * region, size_t region_size, const RingBufferConfig &amp; config) Construct a writer over a shared memory region. RingBufferHeader * header () Access the ring buffer header. void initialize () Initialize the ring buffer header in shared memory. bool try_write (const void * data, size_t len) Write a message to the next slot in the ring buffer."},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferWriter/#detailed-description","title":"Detailed Description","text":"<p>There is exactly one writer per topic. The writer initializes the shared memory header, then writes messages into slots in a circular pattern. After each write, subscribers are woken via futex.</p> <p>See also: RingBufferReader </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferWriter/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferWriter/#function-ringbufferwriter","title":"function RingBufferWriter","text":"<p>Construct a writer over a shared memory region. <pre><code>conduit::internal::RingBufferWriter::RingBufferWriter (\n    void * region,\n    size_t region_size,\n    const  RingBufferConfig &amp; config\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>region</code> Pointer to the shared memory region. </li> <li><code>region_size</code> Total size of the region in bytes. </li> <li><code>config</code> Ring buffer configuration (slot_count must be power of 2). </li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferWriter/#function-header","title":"function header","text":"<p>Access the ring buffer header. <pre><code>inline RingBufferHeader * conduit::internal::RingBufferWriter::header () \n</code></pre></p> <p>Returns:</p> <p>Pointer to the header in shared memory. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferWriter/#function-initialize","title":"function initialize","text":"<p>Initialize the ring buffer header in shared memory. <pre><code>void conduit::internal::RingBufferWriter::initialize () \n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1RingBufferWriter/#function-try_write","title":"function try_write","text":"<p>Write a message to the next slot in the ring buffer. <pre><code>bool conduit::internal::RingBufferWriter::try_write (\n    const  void * data,\n    size_t len\n) \n</code></pre></p> <p>Automatically timestamps the message with CLOCK_MONOTONIC_RAW, increments the sequence number, and wakes waiting subscribers.</p> <p>Parameters:</p> <ul> <li><code>data</code> Pointer to the payload. </li> <li><code>len</code> Payload size in bytes. </li> </ul> <p>Returns:</p> <p>true if written, false if len exceeds the slot's payload capacity. </p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/ring_buffer.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/","title":"Class conduit::internal::ShmRegion","text":"<p>ClassList &gt; conduit &gt; internal &gt; ShmRegion</p> <p>RAII wrapper for a POSIX shared memory region. More...</p> <ul> <li><code>#include &lt;shm_region.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#public-functions","title":"Public Functions","text":"Type Name ShmRegion (ShmRegion &amp;&amp; other) noexceptMove constructor. ShmRegion (const ShmRegion &amp;) = delete void * data () Get a writable pointer to the mapped memory. const void * data () constGet a read-only pointer to the mapped memory. const std::string &amp; name () constGet the region name. ShmRegion &amp; operator= (ShmRegion &amp;&amp; other) noexceptMove assignment operator. ShmRegion &amp; operator= (const ShmRegion &amp;) = delete size_t size () constGet the size of the mapped region. ~ShmRegion () Destructor. Unmaps the memory region (does not unlink)."},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#public-static-functions","title":"Public Static Functions","text":"Type Name ShmRegion create (const std::string &amp; name, size_t size) Create a new shared memory region (used by publishers). bool exists (const std::string &amp; name) Check if a shared memory region exists. ShmRegion open (const std::string &amp; name) Open an existing shared memory region (used by subscribers). void unlink (const std::string &amp; name) Remove the shared memory file from the filesystem. bool wait_until_exists (const std::string &amp; name, const std::atomic&lt; bool &gt; &amp; running, std::chrono::milliseconds poll_interval=std::chrono::milliseconds(100)) Poll until the shared memory region exists or running becomes false."},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#detailed-description","title":"Detailed Description","text":"<p>Provides factory methods to create (publisher) or open (subscriber) a named shared memory region at <code>/dev/shm/conduit_{name}</code>. The region is memory-mapped on construction and unmapped on destruction, but the shared memory file is not unlinked automatically \u2014 call unlink() explicitly when the topic is retired.</p> <p>See also: Publisher, Subscriber </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-shmregion-13","title":"function ShmRegion [1/3]","text":"<p>Move constructor. <pre><code>conduit::internal::ShmRegion::ShmRegion (\n    ShmRegion &amp;&amp; other\n) noexcept\n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-shmregion-23","title":"function ShmRegion [2/3]","text":"<pre><code>conduit::internal::ShmRegion::ShmRegion (\n    const  ShmRegion &amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-data-12","title":"function data [1/2]","text":"<p>Get a writable pointer to the mapped memory. <pre><code>inline void * conduit::internal::ShmRegion::data () \n</code></pre></p> <p>Returns:</p> <p>Pointer to the start of the region. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-data-22","title":"function data [2/2]","text":"<p>Get a read-only pointer to the mapped memory. <pre><code>inline const  void * conduit::internal::ShmRegion::data () const\n</code></pre></p> <p>Returns:</p> <p>Const pointer to the start of the region. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-name","title":"function name","text":"<p>Get the region name. <pre><code>inline const std::string &amp; conduit::internal::ShmRegion::name () const\n</code></pre></p> <p>Returns:</p> <p>Reference to the name string. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-operator","title":"function operator=","text":"<p>Move assignment operator. <pre><code>ShmRegion &amp; conduit::internal::ShmRegion::operator= (\n    ShmRegion &amp;&amp; other\n) noexcept\n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-operator_1","title":"function operator=","text":"<pre><code>ShmRegion &amp; conduit::internal::ShmRegion::operator= (\n    const  ShmRegion &amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-size","title":"function size","text":"<p>Get the size of the mapped region. <pre><code>inline size_t conduit::internal::ShmRegion::size () const\n</code></pre></p> <p>Returns:</p> <p>Size in bytes. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-shmregion","title":"function ~ShmRegion","text":"<p>Destructor. Unmaps the memory region (does not unlink). <pre><code>conduit::internal::ShmRegion::~ShmRegion () \n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-create","title":"function create","text":"<p>Create a new shared memory region (used by publishers). <pre><code>static ShmRegion conduit::internal::ShmRegion::create (\n    const std::string &amp; name,\n    size_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>name</code> Region name (becomes <code>/dev/shm/conduit_{name}</code>). </li> <li><code>size</code> Size in bytes. </li> </ul> <p>Returns:</p> <p>A mapped ShmRegion. </p> <p>Exception:</p> <ul> <li>ShmError If shm_open or mmap fails. </li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-exists","title":"function exists","text":"<p>Check if a shared memory region exists. <pre><code>static bool conduit::internal::ShmRegion::exists (\n    const std::string &amp; name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>name</code> Region name. </li> </ul> <p>Returns:</p> <p>true if the region exists. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-open","title":"function open","text":"<p>Open an existing shared memory region (used by subscribers). <pre><code>static ShmRegion conduit::internal::ShmRegion::open (\n    const std::string &amp; name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>name</code> Region name. </li> </ul> <p>Returns:</p> <p>A mapped ShmRegion. </p> <p>Exception:</p> <ul> <li>ShmError If the region does not exist or mmap fails. </li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-unlink","title":"function unlink","text":"<p>Remove the shared memory file from the filesystem. <pre><code>static void conduit::internal::ShmRegion::unlink (\n    const std::string &amp; name\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>name</code> Region name. </li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1ShmRegion/#function-wait_until_exists","title":"function wait_until_exists","text":"<p>Poll until the shared memory region exists or running becomes false. <pre><code>static bool conduit::internal::ShmRegion::wait_until_exists (\n    const std::string &amp; name,\n    const std::atomic&lt; bool &gt; &amp; running,\n    std::chrono::milliseconds poll_interval=std::chrono::milliseconds(100)\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>name</code> Region name. </li> <li><code>running</code> Atomic flag checked each poll cycle; set to false to abort. </li> <li><code>poll_interval</code> Time between existence checks. </li> </ul> <p>Returns:</p> <p>true if the region now exists, false if stopped early. </p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/shm_region.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/","title":"Class conduit::internal::Subscriber","text":"<p>ClassList &gt; conduit &gt; internal &gt; Subscriber</p> <p>Low-level subscriber that reads raw bytes from a shared memory ring buffer. More...</p> <ul> <li><code>#include &lt;subscriber.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#public-functions","title":"Public Functions","text":"Type Name Subscriber (const std::string &amp; topic, const SubscriberOptions &amp; options={}) Construct a subscriber for the given topic. Subscriber (Subscriber &amp;&amp;) noexceptMove constructor. Subscriber (const Subscriber &amp;) = delete Subscriber &amp; operator= (Subscriber &amp;&amp;) noexceptMove assignment operator. Subscriber &amp; operator= (const Subscriber &amp;) = delete std::optional&lt; Message &gt; take () Non-blocking read of the next message. const std::string &amp; topic () constGet the topic name. Message wait () Block until a message is available. std::optional&lt; Message &gt; wait_for (std::chrono::nanoseconds timeout) Block until a message is available or timeout expires. ~Subscriber ()"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#detailed-description","title":"Detailed Description","text":"<p>Opens an existing shared memory region and claims a reader slot in the lock-free SPMC ring buffer. Use the typed Subscriber&lt;T&gt; wrapper for automatic deserialization.</p> <p>See also: conduit::Subscriber </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#function-subscriber-13","title":"function Subscriber [1/3]","text":"<p>Construct a subscriber for the given topic. <pre><code>conduit::internal::Subscriber::Subscriber (\n    const std::string &amp; topic,\n    const  SubscriberOptions &amp; options={}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>topic</code> Topic name of the shared memory region to open. </li> <li><code>options</code> Subscriber configuration (reserved for future use). </li> </ul> <p>Exception:</p> <ul> <li>SubscriberError If shared memory cannot be opened or no reader slots available. </li> </ul>"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#function-subscriber-23","title":"function Subscriber [2/3]","text":"<p>Move constructor. <pre><code>conduit::internal::Subscriber::Subscriber (\n    Subscriber &amp;&amp;\n) noexcept\n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#function-subscriber-33","title":"function Subscriber [3/3]","text":"<pre><code>conduit::internal::Subscriber::Subscriber (\n    const  Subscriber &amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#function-operator","title":"function operator=","text":"<p>Move assignment operator. <pre><code>Subscriber &amp; conduit::internal::Subscriber::operator= (\n    Subscriber &amp;&amp;\n) noexcept\n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#function-operator_1","title":"function operator=","text":"<pre><code>Subscriber &amp; conduit::internal::Subscriber::operator= (\n    const  Subscriber &amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#function-take","title":"function take","text":"<p>Non-blocking read of the next message. <pre><code>std::optional&lt; Message &gt; conduit::internal::Subscriber::take () \n</code></pre></p> <p>Returns:</p> <p>The next message, or std::nullopt if no new message is available. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#function-topic","title":"function topic","text":"<p>Get the topic name. <pre><code>inline const std::string &amp; conduit::internal::Subscriber::topic () const\n</code></pre></p> <p>Returns:</p> <p>Reference to the topic string. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#function-wait","title":"function wait","text":"<p>Block until a message is available. <pre><code>Message conduit::internal::Subscriber::wait () \n</code></pre></p> <p>Uses futex-based signaling for zero CPU usage while idle.</p> <p>Returns:</p> <p>The next message. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#function-wait_for","title":"function wait_for","text":"<p>Block until a message is available or timeout expires. <pre><code>std::optional&lt; Message &gt; conduit::internal::Subscriber::wait_for (\n    std::chrono::nanoseconds timeout\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>timeout</code> Maximum time to wait. </li> </ul> <p>Returns:</p> <p>The next message, or std::nullopt on timeout. </p>"},{"location":"conduit_core/classconduit_1_1internal_1_1Subscriber/#function-subscriber","title":"function ~Subscriber","text":"<pre><code>conduit::internal::Subscriber::~Subscriber () \n</code></pre> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/subscriber.hpp</code></p>"},{"location":"conduit_core/namespaceconduit_1_1log/","title":"Namespace conduit::log","text":"<p>Namespace List &gt; conduit &gt; log</p> <p>Conduit logging utilities. </p>"},{"location":"conduit_core/namespaceconduit_1_1log/#public-types","title":"Public Types","text":"Type Name enum Level Log severity levels."},{"location":"conduit_core/namespaceconduit_1_1log/#public-functions","title":"Public Functions","text":"Type Name void debug (std::string_view msg) Log a debug message. void debug (fmt::format_string&lt; Args... &gt; fmt, Args &amp;&amp;... args) Log a formatted debug message. void error (std::string_view msg) Log an error message. void error (fmt::format_string&lt; Args... &gt; fmt, Args &amp;&amp;... args) Log a formatted error message. Level get_level () Get the current global log level. void info (std::string_view msg) Log an informational message. void info (fmt::format_string&lt; Args... &gt; fmt, Args &amp;&amp;... args) Log a formatted informational message. void set_level (Level level) Set the global log level. Messages below this level are suppressed. void warn (std::string_view msg) Log a warning message. void warn (fmt::format_string&lt; Args... &gt; fmt, Args &amp;&amp;... args) Log a formatted warning message."},{"location":"conduit_core/namespaceconduit_1_1log/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"conduit_core/namespaceconduit_1_1log/#enum-level","title":"enum Level","text":"<p>Log severity levels. <pre><code>enum conduit::log::Level {\n    Debug,\n    Info,\n    Warn,\n    Error\n};\n</code></pre></p>"},{"location":"conduit_core/namespaceconduit_1_1log/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_core/namespaceconduit_1_1log/#function-debug","title":"function debug","text":"<p>Log a debug message. <pre><code>void conduit::log::debug (\n    std::string_view msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>msg</code> Message string. </li> </ul>"},{"location":"conduit_core/namespaceconduit_1_1log/#function-debug_1","title":"function debug","text":"<p>Log a formatted debug message. <pre><code>template&lt;typename... Args&gt;\nvoid conduit::log::debug (\n    fmt::format_string&lt; Args... &gt; fmt,\n    Args &amp;&amp;... args\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Args</code> Format argument types. </li> </ul> <p>Parameters:</p> <ul> <li><code>fmt</code> Format string (fmt library syntax). </li> <li><code>args</code> Format arguments. </li> </ul>"},{"location":"conduit_core/namespaceconduit_1_1log/#function-error","title":"function error","text":"<p>Log an error message. <pre><code>void conduit::log::error (\n    std::string_view msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>msg</code> Message string. </li> </ul>"},{"location":"conduit_core/namespaceconduit_1_1log/#function-error_1","title":"function error","text":"<p>Log a formatted error message. <pre><code>template&lt;typename... Args&gt;\nvoid conduit::log::error (\n    fmt::format_string&lt; Args... &gt; fmt,\n    Args &amp;&amp;... args\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Args</code> Format argument types. </li> </ul> <p>Parameters:</p> <ul> <li><code>fmt</code> Format string (fmt library syntax). </li> <li><code>args</code> Format arguments. </li> </ul>"},{"location":"conduit_core/namespaceconduit_1_1log/#function-get_level","title":"function get_level","text":"<p>Get the current global log level. <pre><code>Level conduit::log::get_level () \n</code></pre></p> <p>Returns:</p> <p>The active log level. </p>"},{"location":"conduit_core/namespaceconduit_1_1log/#function-info","title":"function info","text":"<p>Log an informational message. <pre><code>void conduit::log::info (\n    std::string_view msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>msg</code> Message string. </li> </ul>"},{"location":"conduit_core/namespaceconduit_1_1log/#function-info_1","title":"function info","text":"<p>Log a formatted informational message. <pre><code>template&lt;typename... Args&gt;\nvoid conduit::log::info (\n    fmt::format_string&lt; Args... &gt; fmt,\n    Args &amp;&amp;... args\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Args</code> Format argument types. </li> </ul> <p>Parameters:</p> <ul> <li><code>fmt</code> Format string (fmt library syntax). </li> <li><code>args</code> Format arguments. </li> </ul>"},{"location":"conduit_core/namespaceconduit_1_1log/#function-set_level","title":"function set_level","text":"<p>Set the global log level. Messages below this level are suppressed. <pre><code>void conduit::log::set_level (\n    Level level\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>level</code> The minimum severity level to output. </li> </ul>"},{"location":"conduit_core/namespaceconduit_1_1log/#function-warn","title":"function warn","text":"<p>Log a warning message. <pre><code>void conduit::log::warn (\n    std::string_view msg\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>msg</code> Message string. </li> </ul>"},{"location":"conduit_core/namespaceconduit_1_1log/#function-warn_1","title":"function warn","text":"<p>Log a formatted warning message. <pre><code>template&lt;typename... Args&gt;\nvoid conduit::log::warn (\n    fmt::format_string&lt; Args... &gt; fmt,\n    Args &amp;&amp;... args\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>Args</code> Format argument types. </li> </ul> <p>Parameters:</p> <ul> <li><code>fmt</code> Format string (fmt library syntax). </li> <li><code>args</code> Format arguments. </li> </ul> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/log.hpp</code></p>"},{"location":"conduit_core/structconduit_1_1Node_1_1Loop/","title":"Struct conduit::Node::Loop","text":"<p>ClassList &gt; Loop</p>"},{"location":"conduit_core/structconduit_1_1Node_1_1Loop/#public-attributes","title":"Public Attributes","text":"Type Name std::function&lt; void()&gt; callback std::chrono::nanoseconds period double rate_hz std::thread thread"},{"location":"conduit_core/structconduit_1_1Node_1_1Loop/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_core/structconduit_1_1Node_1_1Loop/#variable-callback","title":"variable callback","text":"<pre><code>std::function&lt;void()&gt; conduit::Node::Loop::callback;\n</code></pre>"},{"location":"conduit_core/structconduit_1_1Node_1_1Loop/#variable-period","title":"variable period","text":"<pre><code>std::chrono::nanoseconds conduit::Node::Loop::period;\n</code></pre>"},{"location":"conduit_core/structconduit_1_1Node_1_1Loop/#variable-rate_hz","title":"variable rate_hz","text":"<pre><code>double conduit::Node::Loop::rate_hz;\n</code></pre>"},{"location":"conduit_core/structconduit_1_1Node_1_1Loop/#variable-thread","title":"variable thread","text":"<pre><code>std::thread conduit::Node::Loop::thread;\n</code></pre> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/node.hpp</code></p>"},{"location":"conduit_core/structconduit_1_1Node_1_1Subscription/","title":"Struct conduit::Node::Subscription","text":"<p>ClassList &gt; Subscription</p>"},{"location":"conduit_core/structconduit_1_1Node_1_1Subscription/#public-attributes","title":"Public Attributes","text":"Type Name std::function&lt; void(const Message &amp;)&gt; callback std::unique_ptr&lt; internal::Subscriber &gt; subscriber std::thread thread std::string topic"},{"location":"conduit_core/structconduit_1_1Node_1_1Subscription/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_core/structconduit_1_1Node_1_1Subscription/#variable-callback","title":"variable callback","text":"<pre><code>std::function&lt;void(const Message&amp;)&gt; conduit::Node::Subscription::callback;\n</code></pre>"},{"location":"conduit_core/structconduit_1_1Node_1_1Subscription/#variable-subscriber","title":"variable subscriber","text":"<pre><code>std::unique_ptr&lt;internal::Subscriber&gt; conduit::Node::Subscription::subscriber;\n</code></pre>"},{"location":"conduit_core/structconduit_1_1Node_1_1Subscription/#variable-thread","title":"variable thread","text":"<pre><code>std::thread conduit::Node::Subscription::thread;\n</code></pre>"},{"location":"conduit_core/structconduit_1_1Node_1_1Subscription/#variable-topic","title":"variable topic","text":"<pre><code>std::string conduit::Node::Subscription::topic;\n</code></pre> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/node.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1Publisher/","title":"Class conduit::Publisher","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; Publisher</p> <p>Type-safe publisher that serializes messages of type T. More...</p>"},{"location":"conduit_core/classconduit_1_1Publisher/#public-functions","title":"Public Functions","text":"Type Name Publisher (const std::string &amp; topic, const PublisherOptions &amp; options={}) Construct a typed publisher for the given topic. Publisher (Publisher &amp;&amp;) noexceptMove constructor. Publisher (const Publisher &amp;) = delete uint32_t max_message_size () constGet the maximum allowed message size. Publisher &amp; operator= (Publisher &amp;&amp;) noexceptMove assignment operator. Publisher &amp; operator= (const Publisher &amp;) = delete bool publish (const T &amp; msg) Publish a typed message. const std::string &amp; topic () constGet the topic name."},{"location":"conduit_core/classconduit_1_1Publisher/#detailed-description","title":"Detailed Description","text":"<p>For FixedMessageType derivatives, messages are published via memcpy. For VariableMessageType derivatives, serialize() is called into an internal buffer before publishing.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Message type (must derive from FixedMessageType or VariableMessageType). </li> </ul> <p>See also: PublisherOptions, Node::advertise </p>"},{"location":"conduit_core/classconduit_1_1Publisher/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_core/classconduit_1_1Publisher/#function-publisher-13","title":"function Publisher [1/3]","text":"<p>Construct a typed publisher for the given topic. <pre><code>inline Publisher::Publisher (\n    const std::string &amp; topic,\n    const PublisherOptions &amp; options={}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>topic</code> Topic name used to create the shared memory region. </li> <li><code>options</code> Ring buffer configuration. </li> </ul>"},{"location":"conduit_core/classconduit_1_1Publisher/#function-publisher-23","title":"function Publisher [2/3]","text":"<p>Move constructor. <pre><code>Publisher::Publisher (\n    Publisher &amp;&amp;\n) noexcept\n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1Publisher/#function-publisher-33","title":"function Publisher [3/3]","text":"<pre><code>Publisher::Publisher (\n    const Publisher &amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1Publisher/#function-max_message_size","title":"function max_message_size","text":"<p>Get the maximum allowed message size. <pre><code>inline uint32_t Publisher::max_message_size () const\n</code></pre></p> <p>Returns:</p> <p>Maximum payload size in bytes. </p>"},{"location":"conduit_core/classconduit_1_1Publisher/#function-operator","title":"function operator=","text":"<p>Move assignment operator. <pre><code>Publisher &amp; Publisher::operator= (\n    Publisher &amp;&amp;\n) noexcept\n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1Publisher/#function-operator_1","title":"function operator=","text":"<pre><code>Publisher &amp; Publisher::operator= (\n    const Publisher &amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1Publisher/#function-publish","title":"function publish","text":"<p>Publish a typed message. <pre><code>inline bool Publisher::publish (\n    const T &amp; msg\n) \n</code></pre></p> <p>Fixed types are published via memcpy. Variable types are serialized into an internal buffer first.</p> <p>Parameters:</p> <ul> <li><code>msg</code> The message to publish. </li> </ul> <p>Returns:</p> <p>true if the message was written, false if it exceeds max_message_size. </p>"},{"location":"conduit_core/classconduit_1_1Publisher/#function-topic","title":"function topic","text":"<p>Get the topic name. <pre><code>inline const std::string &amp; Publisher::topic () const\n</code></pre></p> <p>Returns:</p> <p>Reference to the topic string. </p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/publisher.hpp</code></p>"},{"location":"conduit_core/classconduit_1_1Subscriber/","title":"Class conduit::Subscriber","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; Subscriber</p> <p>Type-safe subscriber that deserializes messages of type T. More...</p>"},{"location":"conduit_core/classconduit_1_1Subscriber/#public-functions","title":"Public Functions","text":"Type Name Subscriber (const std::string &amp; topic, const SubscriberOptions &amp; options={}) Construct a typed subscriber for the given topic. Subscriber (Subscriber &amp;&amp;) noexceptMove constructor. Subscriber (const Subscriber &amp;) = delete Subscriber &amp; operator= (Subscriber &amp;&amp;) noexceptMove assignment operator. Subscriber &amp; operator= (const Subscriber &amp;) = delete std::optional&lt; TypedMessage&lt; T &gt; &gt; take () Non-blocking read of the next typed message. const std::string &amp; topic () constGet the topic name. TypedMessage&lt; T &gt; wait () Block until a typed message is available. std::optional&lt; TypedMessage&lt; T &gt; &gt; wait_for (std::chrono::nanoseconds timeout) Block until a typed message is available or timeout expires."},{"location":"conduit_core/classconduit_1_1Subscriber/#detailed-description","title":"Detailed Description","text":"<p>For FixedMessageType derivatives, messages are deserialized via memcpy. For VariableMessageType derivatives, T::deserialize() is called.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Message type (must derive from FixedMessageType or VariableMessageType). </li> </ul> <p>See also: SubscriberOptions, Node::subscribe </p>"},{"location":"conduit_core/classconduit_1_1Subscriber/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_core/classconduit_1_1Subscriber/#function-subscriber-13","title":"function Subscriber [1/3]","text":"<p>Construct a typed subscriber for the given topic. <pre><code>inline Subscriber::Subscriber (\n    const std::string &amp; topic,\n    const SubscriberOptions &amp; options={}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>topic</code> Topic name of the shared memory region to open. </li> <li><code>options</code> Subscriber configuration. </li> </ul>"},{"location":"conduit_core/classconduit_1_1Subscriber/#function-subscriber-23","title":"function Subscriber [2/3]","text":"<p>Move constructor. <pre><code>Subscriber::Subscriber (\n    Subscriber &amp;&amp;\n) noexcept\n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1Subscriber/#function-subscriber-33","title":"function Subscriber [3/3]","text":"<pre><code>Subscriber::Subscriber (\n    const Subscriber &amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1Subscriber/#function-operator","title":"function operator=","text":"<p>Move assignment operator. <pre><code>Subscriber &amp; Subscriber::operator= (\n    Subscriber &amp;&amp;\n) noexcept\n</code></pre></p>"},{"location":"conduit_core/classconduit_1_1Subscriber/#function-operator_1","title":"function operator=","text":"<pre><code>Subscriber &amp; Subscriber::operator= (\n    const Subscriber &amp;\n) = delete\n</code></pre>"},{"location":"conduit_core/classconduit_1_1Subscriber/#function-take","title":"function take","text":"<p>Non-blocking read of the next typed message. <pre><code>inline std::optional&lt; TypedMessage&lt; T &gt; &gt; Subscriber::take () \n</code></pre></p> <p>Returns:</p> <p>Deserialized message, or std::nullopt if no new message is available. </p>"},{"location":"conduit_core/classconduit_1_1Subscriber/#function-topic","title":"function topic","text":"<p>Get the topic name. <pre><code>inline const std::string &amp; Subscriber::topic () const\n</code></pre></p> <p>Returns:</p> <p>Reference to the topic string. </p>"},{"location":"conduit_core/classconduit_1_1Subscriber/#function-wait","title":"function wait","text":"<p>Block until a typed message is available. <pre><code>inline TypedMessage&lt; T &gt; Subscriber::wait () \n</code></pre></p> <p>Returns:</p> <p>The next deserialized message. </p>"},{"location":"conduit_core/classconduit_1_1Subscriber/#function-wait_for","title":"function wait_for","text":"<p>Block until a typed message is available or timeout expires. <pre><code>inline std::optional&lt; TypedMessage&lt; T &gt; &gt; Subscriber::wait_for (\n    std::chrono::nanoseconds timeout\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>timeout</code> Maximum time to wait. </li> </ul> <p>Returns:</p> <p>Deserialized message, or std::nullopt on timeout. </p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/subscriber.hpp</code></p>"},{"location":"conduit_core/structconduit_1_1TypedMessage/","title":"Struct conduit::TypedMessage","text":"<p>template &lt;typename T&gt;</p> <p>ClassList &gt; TypedMessage</p> <p>Typed message with deserialized payload. More...</p>"},{"location":"conduit_core/structconduit_1_1TypedMessage/#public-attributes","title":"Public Attributes","text":"Type Name T data Deserialized message payload. uint64_t sequence Monotonically increasing message sequence number. uint64_t timestamp_ns CLOCK_MONOTONIC_RAW timestamp in nanoseconds."},{"location":"conduit_core/structconduit_1_1TypedMessage/#detailed-description","title":"Detailed Description","text":"<p>Template parameters:</p> <ul> <li><code>T</code> The message type. </li> </ul>"},{"location":"conduit_core/structconduit_1_1TypedMessage/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_core/structconduit_1_1TypedMessage/#variable-data","title":"variable data","text":"<p>Deserialized message payload. <pre><code>T conduit::TypedMessage&lt; T &gt;::data;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1TypedMessage/#variable-sequence","title":"variable sequence","text":"<p>Monotonically increasing message sequence number. <pre><code>uint64_t conduit::TypedMessage&lt; T &gt;::sequence;\n</code></pre></p>"},{"location":"conduit_core/structconduit_1_1TypedMessage/#variable-timestamp_ns","title":"variable timestamp_ns","text":"<p>CLOCK_MONOTONIC_RAW timestamp in nanoseconds. <pre><code>uint64_t conduit::TypedMessage&lt; T &gt;::timestamp_ns;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/subscriber.hpp</code></p>"},{"location":"conduit_core/namespacestd/","title":"Namespace std","text":"<p>Namespace List &gt; std</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"conduit_core/dir_93501a11e921083efbd154e0cdff5f10/","title":"Dir packages","text":"<p>FileList &gt; packages</p>"},{"location":"conduit_core/dir_93501a11e921083efbd154e0cdff5f10/#directories","title":"Directories","text":"Type Name dir conduit_core <p>The documentation for this class was generated from the following file <code>packages/</code></p>"},{"location":"conduit_core/dir_e8f2a2a6c23a8405cb81447580d9d2d9/","title":"Dir packages/conduit_core","text":"<p>FileList &gt; conduit_core</p>"},{"location":"conduit_core/dir_e8f2a2a6c23a8405cb81447580d9d2d9/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>packages/conduit_core/</code></p>"},{"location":"conduit_core/dir_e280fcca63980b3efd6dff25fbf50072/","title":"Dir packages/conduit_core/include","text":"<p>FileList &gt; conduit_core &gt; include</p>"},{"location":"conduit_core/dir_e280fcca63980b3efd6dff25fbf50072/#directories","title":"Directories","text":"Type Name dir conduit_core <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/</code></p>"},{"location":"conduit_core/dir_5b31385b73e3aff376fcc12a1f7e93dd/","title":"Dir packages/conduit_core/include/conduit_core","text":"<p>FileList &gt; conduit_core &gt; include &gt; conduit_core</p>"},{"location":"conduit_core/dir_5b31385b73e3aff376fcc12a1f7e93dd/#files","title":"Files","text":"Type Name file exceptions.hpp file log.hpp file node.hpp file publisher.hpp file subscriber.hpp"},{"location":"conduit_core/dir_5b31385b73e3aff376fcc12a1f7e93dd/#directories","title":"Directories","text":"Type Name dir internal <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/</code></p>"},{"location":"conduit_core/exceptions_8hpp/","title":"File exceptions.hpp","text":"<p>FileList &gt; conduit_core &gt; include &gt; conduit_core &gt; exceptions.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;stdexcept&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"conduit_core/exceptions_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_core/exceptions_8hpp/#classes","title":"Classes","text":"Type Name class ConduitError Base exception for all conduit errors. class NodeError Error in Node lifecycle (run, stop, signal handling). class PublisherError Error during publisher creation or publishing. class RingBufferError Error in ring buffer operations (invalid config, overwrite detected). class ShmError Error during shared memory operations (create, open, map). class SubscriberError Error during subscriber creation or message reading. class TankError Error during MCAP recording (file I/O, codec failures). <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/exceptions.hpp</code></p>"},{"location":"conduit_core/exceptions_8hpp_source/","title":"File exceptions.hpp","text":"<p>File List &gt; conduit_core &gt; include &gt; conduit_core &gt; exceptions.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;stdexcept&gt;\n#include &lt;string&gt;\n\nnamespace conduit {\n\nclass ConduitError : public std::runtime_error {\npublic:\n    using std::runtime_error::runtime_error;\n};\n\nclass ShmError : public ConduitError {\npublic:\n    using ConduitError::ConduitError;\n};\n\nclass RingBufferError : public ConduitError {\npublic:\n    using ConduitError::ConduitError;\n};\n\nclass PublisherError : public ConduitError {\npublic:\n    using ConduitError::ConduitError;\n};\n\nclass SubscriberError : public ConduitError {\npublic:\n    using ConduitError::ConduitError;\n};\n\nclass NodeError : public ConduitError {\npublic:\n    using ConduitError::ConduitError;\n};\n\nclass TankError : public ConduitError {\npublic:\n    using ConduitError::ConduitError;\n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_core/log_8hpp/","title":"File log.hpp","text":"<p>FileList &gt; conduit_core &gt; include &gt; conduit_core &gt; log.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string_view&gt;</code></li> <li><code>#include &lt;fmt/format.h&gt;</code></li> </ul>"},{"location":"conduit_core/log_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit namespace log Conduit logging utilities. <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/log.hpp</code></p>"},{"location":"conduit_core/log_8hpp_source/","title":"File log.hpp","text":"<p>File List &gt; conduit_core &gt; include &gt; conduit_core &gt; log.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;string_view&gt;\n#include &lt;fmt/format.h&gt;\n\nnamespace conduit::log {\n\nenum class Level {\n    Debug,   \n    Info,    \n    Warn,    \n    Error    \n};\n\nvoid set_level(Level level);\n\nLevel get_level();\n\nvoid debug(std::string_view msg);\n\nvoid info(std::string_view msg);\n\nvoid warn(std::string_view msg);\n\nvoid error(std::string_view msg);\n\ntemplate&lt;typename... Args&gt;\nvoid debug(fmt::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args) {\n    debug(fmt::format(fmt, std::forward&lt;Args&gt;(args)...));\n}\n\ntemplate&lt;typename... Args&gt;\nvoid info(fmt::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args) {\n    info(fmt::format(fmt, std::forward&lt;Args&gt;(args)...));\n}\n\ntemplate&lt;typename... Args&gt;\nvoid warn(fmt::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args) {\n    warn(fmt::format(fmt, std::forward&lt;Args&gt;(args)...));\n}\n\ntemplate&lt;typename... Args&gt;\nvoid error(fmt::format_string&lt;Args...&gt; fmt, Args&amp;&amp;... args) {\n    error(fmt::format(fmt, std::forward&lt;Args&gt;(args)...));\n}\n\n}  // namespace conduit::log\n</code></pre>"},{"location":"conduit_core/node_8hpp/","title":"File node.hpp","text":"<p>FileList &gt; conduit_core &gt; include &gt; conduit_core &gt; node.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"conduit_core/publisher.hpp\"</code></li> <li><code>#include \"conduit_core/subscriber.hpp\"</code></li> </ul>"},{"location":"conduit_core/node_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_core/node_8hpp/#classes","title":"Classes","text":"Type Name class Node Base class for conduit processing nodes. <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/node.hpp</code></p>"},{"location":"conduit_core/node_8hpp_source/","title":"File node.hpp","text":"<p>File List &gt; conduit_core &gt; include &gt; conduit_core &gt; node.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;functional&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;thread&gt;\n#include &lt;vector&gt;\n\n#include \"conduit_core/publisher.hpp\"\n#include \"conduit_core/subscriber.hpp\"\n\nnamespace conduit {\n\nclass Node {\npublic:\n    Node();\n    virtual ~Node();\n\n    // No copy, no move (prevent slicing)\n    Node(const Node&amp;) = delete;\n    Node&amp; operator=(const Node&amp;) = delete;\n    Node(Node&amp;&amp;) = delete;\n    Node&amp; operator=(Node&amp;&amp;) = delete;\n\n    void run();\n\n    void stop();\n\n    bool running() const;\n\nprotected:\n    template&lt;typename T, typename Func&gt;\n    void subscribe(const std::string&amp; topic, Func T::* callback);\n\n    template&lt;typename MsgT, typename T&gt;\n    void subscribe(const std::string&amp; topic, void (T::* callback)(const TypedMessage&lt;MsgT&gt;&amp;));\n\n    void subscribe(const std::string&amp; topic, std::function&lt;void(const Message&amp;)&gt; callback);\n\n    template&lt;typename T, typename Func&gt;\n    void loop(double rate_hz, Func T::* callback);\n\n    void loop(double rate_hz, std::function&lt;void()&gt; callback);\n\n    template&lt;typename T&gt;\n    Publisher&lt;T&gt; advertise(const std::string&amp; topic, const PublisherOptions&amp; options = {});\n\nprivate:\n    struct Subscription {\n        std::string topic;\n        std::function&lt;void(const Message&amp;)&gt; callback;\n        std::unique_ptr&lt;internal::Subscriber&gt; subscriber;\n        std::thread thread;\n    };\n\n    struct Loop {\n        double rate_hz;\n        std::chrono::nanoseconds period;\n        std::function&lt;void()&gt; callback;\n        std::thread thread;\n    };\n\n    std::vector&lt;std::unique_ptr&lt;Subscription&gt;&gt; subscriptions_;\n    std::vector&lt;std::unique_ptr&lt;Loop&gt;&gt; loops_;\n    std::atomic&lt;bool&gt; running_{false};\n\n    void spin_subscription(Subscription* sub);\n    void spin_loop(Loop* lp);\n\n    // Signal handling\n    static std::atomic&lt;Node*&gt; active_node_;\n    static void signal_handler(int sig);\n    void install_signal_handlers();\n    void uninstall_signal_handlers();\n};\n\n// Template implementations\ntemplate&lt;typename T, typename Func&gt;\nvoid Node::subscribe(const std::string&amp; topic, Func T::* callback) {\n    subscribe(topic, [this, callback](const Message&amp; msg) {\n        (static_cast&lt;T*&gt;(this)-&gt;*callback)(msg);\n    });\n}\n\ntemplate&lt;typename MsgT, typename T&gt;\nvoid Node::subscribe(const std::string&amp; topic, void (T::* callback)(const TypedMessage&lt;MsgT&gt;&amp;)) {\n    subscribe(topic, [this, callback](const Message&amp; msg) {\n        MsgT data = [&amp;]() {\n            if constexpr (std::is_base_of_v&lt;FixedMessageType, MsgT&gt;) {\n                MsgT d;\n                std::memcpy(&amp;d, msg.data, sizeof(MsgT));\n                return d;\n            } else {\n                return MsgT::deserialize(\n                    static_cast&lt;const uint8_t*&gt;(msg.data), msg.size);\n            }\n        }();\n        TypedMessage&lt;MsgT&gt; typed{std::move(data), msg.sequence, msg.timestamp_ns};\n        (static_cast&lt;T*&gt;(this)-&gt;*callback)(typed);\n    });\n}\n\ntemplate&lt;typename T, typename Func&gt;\nvoid Node::loop(double rate_hz, Func T::* callback) {\n    loop(rate_hz, [this, callback]() {\n        (static_cast&lt;T*&gt;(this)-&gt;*callback)();\n    });\n}\n\ntemplate&lt;typename T&gt;\nPublisher&lt;T&gt; Node::advertise(const std::string&amp; topic, const PublisherOptions&amp; options) {\n    return Publisher&lt;T&gt;(topic, options);\n}\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_core/dir_ee09fc54beaf3ba0ab27276c1e0adb4c/","title":"Dir packages/conduit_core/include/conduit_core/internal","text":"<p>FileList &gt; conduit_core &gt; include &gt; conduit_core &gt; internal</p>"},{"location":"conduit_core/dir_ee09fc54beaf3ba0ab27276c1e0adb4c/#files","title":"Files","text":"Type Name file futex.hpp file ring_buffer.hpp file shm_region.hpp file time.hpp <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/</code></p>"},{"location":"conduit_core/futex_8hpp/","title":"File futex.hpp","text":"<p>FileList &gt; conduit_core &gt; include &gt; conduit_core &gt; internal &gt; futex.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> </ul>"},{"location":"conduit_core/futex_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit namespace internal Internal implementation details for conduit. <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/futex.hpp</code></p>"},{"location":"conduit_core/futex_8hpp_source/","title":"File futex.hpp","text":"<p>File List &gt; conduit_core &gt; include &gt; conduit_core &gt; internal &gt; futex.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt;\n#include &lt;optional&gt;\n\nnamespace conduit::internal {\n\nbool futex_wait(\n    std::atomic&lt;uint32_t&gt;* futex_word,\n    uint32_t expected_value,\n    std::optional&lt;std::chrono::nanoseconds&gt; timeout = std::nullopt\n);\n\nint futex_wake(std::atomic&lt;uint32_t&gt;* futex_word, int count = 1);\n\nint futex_wake_all(std::atomic&lt;uint32_t&gt;* futex_word);\n\n}  // namespace conduit::internal\n</code></pre>"},{"location":"conduit_core/ring__buffer_8hpp/","title":"File ring_buffer.hpp","text":"<p>FileList &gt; conduit_core &gt; include &gt; conduit_core &gt; internal &gt; ring_buffer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> </ul>"},{"location":"conduit_core/ring__buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit namespace internal Internal implementation details for conduit."},{"location":"conduit_core/ring__buffer_8hpp/#classes","title":"Classes","text":"Type Name struct AlignedAtomicU64 Cache-line-aligned atomic uint64_t to prevent false sharing. struct ReadResult Result of a successful ring buffer read. struct RingBufferConfig Ring buffer configuration. struct RingBufferHeader Shared memory layout for the ring buffer control structure. class RingBufferReader Reader side of the lock-free SPMC ring buffer. class RingBufferWriter Writer side of the lock-free SPMC ring buffer. <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/ring_buffer.hpp</code></p>"},{"location":"conduit_core/ring__buffer_8hpp_source/","title":"File ring_buffer.hpp","text":"<p>File List &gt; conduit_core &gt; include &gt; conduit_core &gt; internal &gt; ring_buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;optional&gt;\n\nnamespace conduit {\nnamespace internal {\n\nconstexpr size_t CACHE_LINE_SIZE = 64;\n\nconstexpr size_t MAX_SUBSCRIBERS = 16;\n\nconstexpr size_t SLOT_HEADER_SIZE = sizeof(uint32_t) + sizeof(uint64_t) + sizeof(uint64_t);  // 20 bytes\n\nstruct RingBufferConfig {\n    uint32_t slot_count;    \n    uint32_t slot_size;     \n};\n\nstruct ReadResult {\n    const void* data;       \n    size_t size;            \n    uint64_t sequence;      \n    uint64_t timestamp_ns;  \n};\n\nstruct alignas(CACHE_LINE_SIZE) AlignedAtomicU64 {\n    std::atomic&lt;uint64_t&gt; value;\n};\n\nstruct RingBufferHeader {\n    // Configuration (immutable after init)\n    uint32_t slot_count;        \n    uint32_t slot_size;         \n    uint32_t max_subscribers;   \n    uint32_t padding0;          \n\n    alignas(CACHE_LINE_SIZE) std::atomic&lt;uint64_t&gt; write_idx;\n\n    alignas(CACHE_LINE_SIZE) std::atomic&lt;uint32_t&gt; subscriber_mask;\n    std::atomic&lt;uint32_t&gt; futex_word;\n\n    alignas(CACHE_LINE_SIZE) AlignedAtomicU64 read_idx[MAX_SUBSCRIBERS];\n};\n\ninline bool is_power_of_two(uint32_t n) {\n    return n &gt; 0 &amp;&amp; (n &amp; (n - 1)) == 0;\n}\n\ninline size_t calculate_region_size(const RingBufferConfig&amp; config) {\n    return sizeof(RingBufferHeader) + static_cast&lt;size_t&gt;(config.slot_count) * config.slot_size;\n}\n\nclass RingBufferWriter {\npublic:\n    RingBufferWriter(void* region, size_t region_size, const RingBufferConfig&amp; config);\n\n    void initialize();\n\n    bool try_write(const void* data, size_t len);\n\n    RingBufferHeader* header() { return header_; }\n\nprivate:\n    RingBufferHeader* header_;\n    uint8_t* slots_;\n    uint32_t slot_size_;\n    uint32_t slot_count_;\n    uint32_t slot_count_mask_;\n};\n\nclass RingBufferReader {\npublic:\n    RingBufferReader(void* region, size_t region_size);\n\n    int claim_slot();\n\n    void release_slot(int slot);\n\n    std::optional&lt;ReadResult&gt; try_read(int slot);\n\n    std::optional&lt;ReadResult&gt; wait(int slot);\n\n    std::optional&lt;ReadResult&gt; wait_for(int slot, std::chrono::nanoseconds timeout);\n\n    RingBufferHeader* header() { return header_; }\n\nprivate:\n    RingBufferHeader* header_;\n    uint8_t* slots_;\n    uint32_t slot_size_;\n    uint32_t slot_count_mask_;\n};\n\n}  // namespace internal\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_core/shm__region_8hpp/","title":"File shm_region.hpp","text":"<p>FileList &gt; conduit_core &gt; include &gt; conduit_core &gt; internal &gt; shm_region.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"conduit_core/shm__region_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit namespace internal Internal implementation details for conduit."},{"location":"conduit_core/shm__region_8hpp/#classes","title":"Classes","text":"Type Name class ShmRegion RAII wrapper for a POSIX shared memory region. <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/shm_region.hpp</code></p>"},{"location":"conduit_core/shm__region_8hpp_source/","title":"File shm_region.hpp","text":"<p>File List &gt; conduit_core &gt; include &gt; conduit_core &gt; internal &gt; shm_region.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;chrono&gt;\n#include &lt;cstddef&gt;\n#include &lt;string&gt;\n\nnamespace conduit {\nnamespace internal {\n\nclass ShmRegion {\npublic:\n    static ShmRegion create(const std::string&amp; name, size_t size);\n\n    static ShmRegion open(const std::string&amp; name);\n\n    static bool exists(const std::string&amp; name);\n\n    static bool wait_until_exists(const std::string&amp; name,\n                                  const std::atomic&lt;bool&gt;&amp; running,\n                                  std::chrono::milliseconds poll_interval = std::chrono::milliseconds(100));\n\n    static void unlink(const std::string&amp; name);\n\n    ShmRegion(ShmRegion&amp;&amp; other) noexcept;\n    ShmRegion&amp; operator=(ShmRegion&amp;&amp; other) noexcept;\n    ShmRegion(const ShmRegion&amp;) = delete;\n    ShmRegion&amp; operator=(const ShmRegion&amp;) = delete;\n\n    ~ShmRegion();\n\n    void* data() { return data_; }\n\n    const void* data() const { return data_; }\n\n    size_t size() const { return size_; }\n\n    const std::string&amp; name() const { return name_; }\n\nprivate:\n    ShmRegion(const std::string&amp; name, void* data, size_t size);\n\n    std::string name_;\n    void* data_;\n    size_t size_;\n};\n\n}  // namespace internal\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_core/time_8hpp/","title":"File time.hpp","text":"<p>FileList &gt; conduit_core &gt; include &gt; conduit_core &gt; internal &gt; time.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"conduit_core/time_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit namespace internal Internal implementation details for conduit. <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/internal/time.hpp</code></p>"},{"location":"conduit_core/time_8hpp_source/","title":"File time.hpp","text":"<p>File List &gt; conduit_core &gt; include &gt; conduit_core &gt; internal &gt; time.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n\nnamespace conduit::internal {\n\nuint64_t get_timestamp_ns();\n\n}  // namespace conduit::internal\n</code></pre>"},{"location":"conduit_core/publisher_8hpp/","title":"File publisher.hpp","text":"<p>FileList &gt; conduit_core &gt; include &gt; conduit_core &gt; publisher.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> <li><code>#include \"conduit_core/internal/ring_buffer.hpp\"</code></li> <li><code>#include \"conduit_core/internal/shm_region.hpp\"</code></li> <li><code>#include &lt;conduit_types/fixed_message_type.hpp&gt;</code></li> <li><code>#include &lt;conduit_types/variable_message_type.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/publisher_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit namespace internal Internal implementation details for conduit."},{"location":"conduit_core/publisher_8hpp/#classes","title":"Classes","text":"Type Name struct PublisherOptions Configuration for topic publisher and ring buffer sizing. class Publisher Low-level publisher that writes raw bytes to a shared memory ring buffer. <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/publisher.hpp</code></p>"},{"location":"conduit_core/publisher_8hpp_source/","title":"File publisher.hpp","text":"<p>File List &gt; conduit_core &gt; include &gt; conduit_core &gt; publisher.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n#include &lt;vector&gt;\n\n#include \"conduit_core/internal/ring_buffer.hpp\"\n#include \"conduit_core/internal/shm_region.hpp\"\n\nnamespace conduit {\n\nstruct PublisherOptions {\n    uint32_t depth = 16;\n    uint32_t max_message_size = 4096;\n};\n\nnamespace internal {\n\nclass Publisher {\npublic:\n    Publisher(const std::string&amp; topic, const PublisherOptions&amp; options = {});\n\n    Publisher(Publisher&amp;&amp;) noexcept;\n    Publisher&amp; operator=(Publisher&amp;&amp;) noexcept;\n    Publisher(const Publisher&amp;) = delete;\n    Publisher&amp; operator=(const Publisher&amp;) = delete;\n\n    ~Publisher();\n\n    bool publish(const void* data, size_t size);\n\n    const std::string&amp; topic() const { return topic_; }\n\n    uint32_t max_message_size() const { return max_message_size_; }\n\nprivate:\n    std::string topic_;\n    uint32_t max_message_size_;\n    ShmRegion shm_;\n    std::unique_ptr&lt;RingBufferWriter&gt; writer_;\n};\n\n}  // namespace internal\n\n}  // namespace conduit\n\n// Include message type traits for Publisher&lt;T&gt;\n#include &lt;conduit_types/fixed_message_type.hpp&gt;\n#include &lt;conduit_types/variable_message_type.hpp&gt;\n\nnamespace conduit {\n\ntemplate &lt;typename T&gt;\nclass Publisher {\npublic:\n    Publisher(const std::string&amp; topic, const PublisherOptions&amp; options = {})\n        : impl_(topic, options) {\n        validate();\n    }\n\n    Publisher(Publisher&amp;&amp;) noexcept = default;\n    Publisher&amp; operator=(Publisher&amp;&amp;) noexcept = default;\n    Publisher(const Publisher&amp;) = delete;\n    Publisher&amp; operator=(const Publisher&amp;) = delete;\n\n    bool publish(const T&amp; msg) {\n        if constexpr (std::is_base_of_v&lt;FixedMessageType, T&gt;) {\n            return impl_.publish(&amp;msg, sizeof(T));\n        } else {\n            size_t size = msg.serialized_size();\n            buffer_.resize(size);\n            msg.serialize(buffer_.data());\n            return impl_.publish(buffer_.data(), size);\n        }\n    }\n\n    const std::string&amp; topic() const { return impl_.topic(); }\n\n    uint32_t max_message_size() const { return impl_.max_message_size(); }\n\nprivate:\n    internal::Publisher impl_;\n    std::vector&lt;uint8_t&gt; buffer_;  \n\n    static constexpr void validate() {\n        if constexpr (std::is_base_of_v&lt;FixedMessageType, T&gt;) {\n            validate_fixed_message_type&lt;T&gt;();\n        } else {\n            validate_variable_message_type&lt;T&gt;();\n        }\n    }\n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_core/subscriber_8hpp/","title":"File subscriber.hpp","text":"<p>FileList &gt; conduit_core &gt; include &gt; conduit_core &gt; subscriber.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> <li><code>#include \"conduit_core/internal/ring_buffer.hpp\"</code></li> <li><code>#include \"conduit_core/internal/shm_region.hpp\"</code></li> <li><code>#include &lt;conduit_types/fixed_message_type.hpp&gt;</code></li> <li><code>#include &lt;conduit_types/variable_message_type.hpp&gt;</code></li> </ul>"},{"location":"conduit_core/subscriber_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit namespace internal Internal implementation details for conduit."},{"location":"conduit_core/subscriber_8hpp/#classes","title":"Classes","text":"Type Name struct Message Raw message received from a topic. struct SubscriberOptions Configuration for topic subscriber. class Subscriber Low-level subscriber that reads raw bytes from a shared memory ring buffer. <p>The documentation for this class was generated from the following file <code>packages/conduit_core/include/conduit_core/subscriber.hpp</code></p>"},{"location":"conduit_core/subscriber_8hpp_source/","title":"File subscriber.hpp","text":"<p>File List &gt; conduit_core &gt; include &gt; conduit_core &gt; subscriber.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n#include &lt;memory&gt;\n#include &lt;optional&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\n#include \"conduit_core/internal/ring_buffer.hpp\"\n#include \"conduit_core/internal/shm_region.hpp\"\n\nnamespace conduit {\n\nstruct SubscriberOptions {\n    // reserved for future use\n};\n\nstruct Message {\n    const void* data;        \n    size_t size;             \n    uint64_t sequence;       \n    uint64_t timestamp_ns;   \n};\n\nnamespace internal {\n\nclass Subscriber {\npublic:\n    Subscriber(const std::string&amp; topic, const SubscriberOptions&amp; options = {});\n\n    Subscriber(Subscriber&amp;&amp;) noexcept;\n    Subscriber&amp; operator=(Subscriber&amp;&amp;) noexcept;\n    Subscriber(const Subscriber&amp;) = delete;\n    Subscriber&amp; operator=(const Subscriber&amp;) = delete;\n\n    ~Subscriber();\n\n    std::optional&lt;Message&gt; take();\n\n    Message wait();\n\n    std::optional&lt;Message&gt; wait_for(std::chrono::nanoseconds timeout);\n\n    const std::string&amp; topic() const { return topic_; }\n\nprivate:\n    std::string topic_;\n    ShmRegion shm_;\n    std::unique_ptr&lt;RingBufferReader&gt; reader_;\n    int slot_;\n};\n\n}  // namespace internal\n\n}  // namespace conduit\n\n// Include message type traits for Subscriber&lt;T&gt;\n#include &lt;conduit_types/fixed_message_type.hpp&gt;\n#include &lt;conduit_types/variable_message_type.hpp&gt;\n\nnamespace conduit {\n\ntemplate &lt;typename T&gt;\nstruct TypedMessage {\n    T data;                  \n    uint64_t sequence;       \n    uint64_t timestamp_ns;   \n};\n\ntemplate &lt;typename T&gt;\nclass Subscriber {\npublic:\n    Subscriber(const std::string&amp; topic, const SubscriberOptions&amp; options = {})\n        : impl_(topic, options) {\n        validate();\n    }\n\n    Subscriber(Subscriber&amp;&amp;) noexcept = default;\n    Subscriber&amp; operator=(Subscriber&amp;&amp;) noexcept = default;\n    Subscriber(const Subscriber&amp;) = delete;\n    Subscriber&amp; operator=(const Subscriber&amp;) = delete;\n\n    std::optional&lt;TypedMessage&lt;T&gt;&gt; take() {\n        auto msg = impl_.take();\n        if (!msg) return std::nullopt;\n        return convert(*msg);\n    }\n\n    TypedMessage&lt;T&gt; wait() {\n        return convert(impl_.wait());\n    }\n\n    std::optional&lt;TypedMessage&lt;T&gt;&gt; wait_for(std::chrono::nanoseconds timeout) {\n        auto msg = impl_.wait_for(timeout);\n        if (!msg) return std::nullopt;\n        return convert(*msg);\n    }\n\n    const std::string&amp; topic() const { return impl_.topic(); }\n\nprivate:\n    internal::Subscriber impl_;\n\n    static TypedMessage&lt;T&gt; convert(const Message&amp; msg) {\n        T data = [&amp;]() {\n            if constexpr (std::is_base_of_v&lt;FixedMessageType, T&gt;) {\n                T d;\n                std::memcpy(&amp;d, msg.data, sizeof(T));\n                return d;\n            } else {\n                return T::deserialize(\n                    static_cast&lt;const uint8_t*&gt;(msg.data), msg.size);\n            }\n        }();\n        return TypedMessage&lt;T&gt;{std::move(data), msg.sequence, msg.timestamp_ns};\n    }\n\n    static constexpr void validate() {\n        if constexpr (std::is_base_of_v&lt;FixedMessageType, T&gt;) {\n            validate_fixed_message_type&lt;T&gt;();\n        } else {\n            validate_variable_message_type&lt;T&gt;();\n        }\n    }\n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_core/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace conduit <ul> <li>namespace internal Internal implementation details for conduit. </li> <li>namespace log Conduit logging utilities. </li> </ul> </li> <li>namespace std </li> </ul>"},{"location":"conduit_core/classes/","title":"Class Index","text":""},{"location":"conduit_core/classes/#a","title":"a","text":"<ul> <li>AlignedAtomicU64 (conduit::internal)</li> </ul>"},{"location":"conduit_core/classes/#c","title":"c","text":"<ul> <li>ConduitError (conduit)</li> </ul>"},{"location":"conduit_core/classes/#l","title":"l","text":"<ul> <li>Loop</li> </ul>"},{"location":"conduit_core/classes/#m","title":"m","text":"<ul> <li>Message (conduit)</li> </ul>"},{"location":"conduit_core/classes/#n","title":"n","text":"<ul> <li>Node (conduit)</li> <li>NodeError (conduit)</li> </ul>"},{"location":"conduit_core/classes/#p","title":"p","text":"<ul> <li>Publisher (conduit::internal)</li> <li>Publisher</li> <li>PublisherError (conduit)</li> <li>PublisherOptions (conduit)</li> </ul>"},{"location":"conduit_core/classes/#r","title":"r","text":"<ul> <li>ReadResult (conduit::internal)</li> <li>RingBufferConfig (conduit::internal)</li> <li>RingBufferError (conduit)</li> <li>RingBufferHeader (conduit::internal)</li> <li>RingBufferReader (conduit::internal)</li> <li>RingBufferWriter (conduit::internal)</li> </ul>"},{"location":"conduit_core/classes/#s","title":"s","text":"<ul> <li>ShmError (conduit)</li> <li>ShmRegion (conduit::internal)</li> <li>Subscriber (conduit::internal)</li> <li>Subscriber</li> <li>SubscriberError (conduit)</li> <li>SubscriberOptions (conduit)</li> <li>Subscription</li> </ul>"},{"location":"conduit_core/classes/#t","title":"t","text":"<ul> <li>TankError (conduit)</li> <li>TypedMessage</li> </ul>"},{"location":"conduit_core/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class conduit::Node Base class for conduit processing nodes. </li> <li>class conduit::internal::Publisher Low-level publisher that writes raw bytes to a shared memory ring buffer. </li> <li>class conduit::internal::RingBufferReader Reader side of the lock-free SPMC ring buffer. </li> <li>class conduit::internal::RingBufferWriter Writer side of the lock-free SPMC ring buffer. </li> <li>class conduit::internal::ShmRegion RAII wrapper for a POSIX shared memory region. </li> <li>class conduit::internal::Subscriber Low-level subscriber that reads raw bytes from a shared memory ring buffer. </li> <li>class conduit::Publisher Type-safe publisher that serializes messages of type T. </li> <li>class conduit::Subscriber Type-safe subscriber that deserializes messages of type T. </li> <li>struct conduit::Message Raw message received from a topic. </li> <li>struct conduit::PublisherOptions Configuration for topic publisher and ring buffer sizing. </li> <li>struct conduit::SubscriberOptions Configuration for topic subscriber. </li> <li>struct conduit::internal::AlignedAtomicU64 Cache-line-aligned atomic uint64_t to prevent false sharing. </li> <li>struct conduit::internal::ReadResult Result of a successful ring buffer read. </li> <li>struct conduit::internal::RingBufferConfig Ring buffer configuration. </li> <li>struct conduit::internal::RingBufferHeader Shared memory layout for the ring buffer control structure. </li> <li>struct conduit::Node::Loop </li> <li>struct conduit::Node::Subscription </li> <li>struct conduit::TypedMessage Typed message with deserialized payload. </li> <li>class std::runtime_error <ul> <li>class conduit::ConduitError Base exception for all conduit errors. <ul> <li>class conduit::NodeError Error in Node lifecycle (run, stop, signal handling).</li> <li>class conduit::PublisherError Error during publisher creation or publishing. </li> <li>class conduit::RingBufferError Error in ring buffer operations (invalid config, overwrite detected). </li> <li>class conduit::ShmError Error during shared memory operations (create, open, map). </li> <li>class conduit::SubscriberError Error during subscriber creation or message reading. </li> <li>class conduit::TankError Error during MCAP recording (file I/O, codec failures). </li> </ul> </li> <li>class conduit::ConduitError Base exception for all conduit errors. <ul> <li>class conduit::NodeError Error in Node lifecycle (run, stop, signal handling).</li> <li>class conduit::PublisherError Error during publisher creation or publishing. </li> <li>class conduit::RingBufferError Error in ring buffer operations (invalid config, overwrite detected). </li> <li>class conduit::ShmError Error during shared memory operations (create, open, map). </li> <li>class conduit::SubscriberError Error during subscriber creation or message reading. </li> <li>class conduit::TankError Error during MCAP recording (file I/O, codec failures). </li> </ul> </li> <li>class conduit::ConduitError Base exception for all conduit errors. <ul> <li>class conduit::NodeError Error in Node lifecycle (run, stop, signal handling).</li> <li>class conduit::PublisherError Error during publisher creation or publishing. </li> <li>class conduit::RingBufferError Error in ring buffer operations (invalid config, overwrite detected). </li> <li>class conduit::ShmError Error during shared memory operations (create, open, map). </li> <li>class conduit::SubscriberError Error during subscriber creation or message reading. </li> <li>class conduit::TankError Error during MCAP recording (file I/O, codec failures). </li> </ul> </li> <li>class conduit::ConduitError Base exception for all conduit errors. <ul> <li>class conduit::NodeError Error in Node lifecycle (run, stop, signal handling).</li> <li>class conduit::PublisherError Error during publisher creation or publishing. </li> <li>class conduit::RingBufferError Error in ring buffer operations (invalid config, overwrite detected). </li> <li>class conduit::ShmError Error during shared memory operations (create, open, map). </li> <li>class conduit::SubscriberError Error during subscriber creation or message reading. </li> <li>class conduit::TankError Error during MCAP recording (file I/O, codec failures). </li> </ul> </li> <li>class conduit::ConduitError Base exception for all conduit errors. <ul> <li>class conduit::NodeError Error in Node lifecycle (run, stop, signal handling).</li> <li>class conduit::PublisherError Error during publisher creation or publishing. </li> <li>class conduit::RingBufferError Error in ring buffer operations (invalid config, overwrite detected). </li> <li>class conduit::ShmError Error during shared memory operations (create, open, map). </li> <li>class conduit::SubscriberError Error during subscriber creation or message reading. </li> <li>class conduit::TankError Error during MCAP recording (file I/O, codec failures). </li> </ul> </li> <li>class conduit::ConduitError Base exception for all conduit errors. <ul> <li>class conduit::NodeError Error in Node lifecycle (run, stop, signal handling).</li> <li>class conduit::PublisherError Error during publisher creation or publishing. </li> <li>class conduit::RingBufferError Error in ring buffer operations (invalid config, overwrite detected). </li> <li>class conduit::ShmError Error during shared memory operations (create, open, map). </li> <li>class conduit::SubscriberError Error during subscriber creation or message reading. </li> <li>class conduit::TankError Error during MCAP recording (file I/O, codec failures). </li> </ul> </li> <li>class conduit::ConduitError Base exception for all conduit errors. <ul> <li>class conduit::NodeError Error in Node lifecycle (run, stop, signal handling).</li> <li>class conduit::PublisherError Error during publisher creation or publishing. </li> <li>class conduit::RingBufferError Error in ring buffer operations (invalid config, overwrite detected). </li> <li>class conduit::ShmError Error during shared memory operations (create, open, map). </li> <li>class conduit::SubscriberError Error during subscriber creation or message reading. </li> <li>class conduit::TankError Error during MCAP recording (file I/O, codec failures). </li> </ul> </li> </ul> </li> </ul>"},{"location":"conduit_core/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"conduit_core/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"conduit_core/class_members/","title":"Class Members","text":""},{"location":"conduit_core/class_members/#a","title":"a","text":"<ul> <li>active_node_ (conduit::Node)</li> <li>advertise (conduit::Node)</li> </ul>"},{"location":"conduit_core/class_members/#b","title":"b","text":"<ul> <li>buffer_ (conduit::Publisher)</li> </ul>"},{"location":"conduit_core/class_members/#c","title":"c","text":"<ul> <li>claim_slot (conduit::internal::RingBufferReader)</li> <li>create (conduit::internal::ShmRegion)</li> <li>callback (conduit::Node::Loop, conduit::Node::Subscription)</li> <li>convert (conduit::Subscriber)</li> </ul>"},{"location":"conduit_core/class_members/#d","title":"d","text":"<ul> <li>data (conduit::Message, conduit::internal::ReadResult, conduit::internal::ShmRegion, conduit::TypedMessage)</li> <li>depth (conduit::PublisherOptions)</li> <li>data_ (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_members/#e","title":"e","text":"<ul> <li>exists (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_members/#f","title":"f","text":"<ul> <li>futex_word (conduit::internal::RingBufferHeader)</li> </ul>"},{"location":"conduit_core/class_members/#h","title":"h","text":"<ul> <li>header (conduit::internal::RingBufferReader, conduit::internal::RingBufferWriter)</li> <li>header_ (conduit::internal::RingBufferReader, conduit::internal::RingBufferWriter)</li> </ul>"},{"location":"conduit_core/class_members/#i","title":"i","text":"<ul> <li>install_signal_handlers (conduit::Node)</li> <li>initialize (conduit::internal::RingBufferWriter)</li> <li>impl_ (conduit::Publisher, conduit::Subscriber)</li> </ul>"},{"location":"conduit_core/class_members/#l","title":"l","text":"<ul> <li>loop (conduit::Node)</li> <li>loops_ (conduit::Node)</li> </ul>"},{"location":"conduit_core/class_members/#m","title":"m","text":"<ul> <li>max_message_size (conduit::PublisherOptions, conduit::internal::Publisher, conduit::Publisher)</li> <li>max_message_size_ (conduit::internal::Publisher)</li> <li>max_subscribers (conduit::internal::RingBufferHeader)</li> </ul>"},{"location":"conduit_core/class_members/#n","title":"n","text":"<ul> <li>Node (conduit::Node)</li> <li>name (conduit::internal::ShmRegion)</li> <li>name_ (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_members/#o","title":"o","text":"<ul> <li>operator= (conduit::Node, conduit::internal::Publisher, conduit::internal::ShmRegion, conduit::internal::Subscriber, conduit::Publisher, conduit::Subscriber)</li> <li>open (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_members/#p","title":"p","text":"<ul> <li>Publisher (conduit::internal::Publisher, conduit::Publisher)</li> <li>publish (conduit::internal::Publisher, conduit::Publisher)</li> <li>padding0 (conduit::internal::RingBufferHeader)</li> <li>period (conduit::Node::Loop)</li> </ul>"},{"location":"conduit_core/class_members/#r","title":"r","text":"<ul> <li>run (conduit::Node)</li> <li>running (conduit::Node)</li> <li>running_ (conduit::Node)</li> <li>read_idx (conduit::internal::RingBufferHeader)</li> <li>RingBufferReader (conduit::internal::RingBufferReader)</li> <li>release_slot (conduit::internal::RingBufferReader)</li> <li>RingBufferWriter (conduit::internal::RingBufferWriter)</li> <li>reader_ (conduit::internal::Subscriber)</li> <li>rate_hz (conduit::Node::Loop)</li> </ul>"},{"location":"conduit_core/class_members/#s","title":"s","text":"<ul> <li>sequence (conduit::Message, conduit::internal::ReadResult, conduit::TypedMessage)</li> <li>size (conduit::Message, conduit::internal::ReadResult, conduit::internal::ShmRegion)</li> <li>signal_handler (conduit::Node)</li> <li>spin_loop (conduit::Node)</li> <li>spin_subscription (conduit::Node)</li> <li>stop (conduit::Node)</li> <li>subscribe (conduit::Node)</li> <li>subscriptions_ (conduit::Node)</li> <li>shm_ (conduit::internal::Publisher, conduit::internal::Subscriber)</li> <li>slot_count (conduit::internal::RingBufferConfig, conduit::internal::RingBufferHeader)</li> <li>slot_size (conduit::internal::RingBufferConfig, conduit::internal::RingBufferHeader)</li> <li>subscriber_mask (conduit::internal::RingBufferHeader)</li> <li>slot_count_mask_ (conduit::internal::RingBufferReader, conduit::internal::RingBufferWriter)</li> <li>slot_size_ (conduit::internal::RingBufferReader, conduit::internal::RingBufferWriter)</li> <li>slots_ (conduit::internal::RingBufferReader, conduit::internal::RingBufferWriter)</li> <li>slot_count_ (conduit::internal::RingBufferWriter)</li> <li>ShmRegion (conduit::internal::ShmRegion)</li> <li>size_ (conduit::internal::ShmRegion)</li> <li>Subscriber (conduit::internal::Subscriber, conduit::Subscriber)</li> <li>slot_ (conduit::internal::Subscriber)</li> <li>subscriber (conduit::Node::Subscription)</li> </ul>"},{"location":"conduit_core/class_members/#t","title":"t","text":"<ul> <li>timestamp_ns (conduit::Message, conduit::internal::ReadResult, conduit::TypedMessage)</li> <li>topic (conduit::internal::Publisher, conduit::internal::Subscriber, conduit::Node::Subscription, conduit::Publisher, conduit::Subscriber)</li> <li>topic_ (conduit::internal::Publisher, conduit::internal::Subscriber)</li> <li>try_read (conduit::internal::RingBufferReader)</li> <li>try_write (conduit::internal::RingBufferWriter)</li> <li>take (conduit::internal::Subscriber, conduit::Subscriber)</li> <li>thread (conduit::Node::Loop, conduit::Node::Subscription)</li> </ul>"},{"location":"conduit_core/class_members/#u","title":"u","text":"<ul> <li>uninstall_signal_handlers (conduit::Node)</li> <li>unlink (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_members/#v","title":"v","text":"<ul> <li>value (conduit::internal::AlignedAtomicU64)</li> <li>validate (conduit::Publisher, conduit::Subscriber)</li> </ul>"},{"location":"conduit_core/class_members/#w","title":"w","text":"<ul> <li>writer_ (conduit::internal::Publisher)</li> <li>write_idx (conduit::internal::RingBufferHeader)</li> <li>wait (conduit::internal::RingBufferReader, conduit::internal::Subscriber, conduit::Subscriber)</li> <li>wait_for (conduit::internal::RingBufferReader, conduit::internal::Subscriber, conduit::Subscriber)</li> <li>wait_until_exists (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_members/#_1","title":"~","text":"<ul> <li>~Node (conduit::Node)</li> <li>~Publisher (conduit::internal::Publisher)</li> <li>~ShmRegion (conduit::internal::ShmRegion)</li> <li>~Subscriber (conduit::internal::Subscriber)</li> </ul>"},{"location":"conduit_core/class_member_functions/","title":"Class Member Functions","text":""},{"location":"conduit_core/class_member_functions/#a","title":"a","text":"<ul> <li>advertise (conduit::Node)</li> </ul>"},{"location":"conduit_core/class_member_functions/#c","title":"c","text":"<ul> <li>claim_slot (conduit::internal::RingBufferReader)</li> <li>create (conduit::internal::ShmRegion)</li> <li>convert (conduit::Subscriber)</li> </ul>"},{"location":"conduit_core/class_member_functions/#d","title":"d","text":"<ul> <li>data (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_member_functions/#e","title":"e","text":"<ul> <li>exists (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_member_functions/#h","title":"h","text":"<ul> <li>header (conduit::internal::RingBufferReader, conduit::internal::RingBufferWriter)</li> </ul>"},{"location":"conduit_core/class_member_functions/#i","title":"i","text":"<ul> <li>install_signal_handlers (conduit::Node)</li> <li>initialize (conduit::internal::RingBufferWriter)</li> </ul>"},{"location":"conduit_core/class_member_functions/#l","title":"l","text":"<ul> <li>loop (conduit::Node)</li> </ul>"},{"location":"conduit_core/class_member_functions/#m","title":"m","text":"<ul> <li>max_message_size (conduit::internal::Publisher, conduit::Publisher)</li> </ul>"},{"location":"conduit_core/class_member_functions/#n","title":"n","text":"<ul> <li>Node (conduit::Node)</li> <li>name (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (conduit::Node, conduit::internal::Publisher, conduit::internal::ShmRegion, conduit::internal::Subscriber, conduit::Publisher, conduit::Subscriber)</li> <li>open (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_member_functions/#p","title":"p","text":"<ul> <li>Publisher (conduit::internal::Publisher, conduit::Publisher)</li> <li>publish (conduit::internal::Publisher, conduit::Publisher)</li> </ul>"},{"location":"conduit_core/class_member_functions/#r","title":"r","text":"<ul> <li>run (conduit::Node)</li> <li>running (conduit::Node)</li> <li>RingBufferReader (conduit::internal::RingBufferReader)</li> <li>release_slot (conduit::internal::RingBufferReader)</li> <li>RingBufferWriter (conduit::internal::RingBufferWriter)</li> </ul>"},{"location":"conduit_core/class_member_functions/#s","title":"s","text":"<ul> <li>signal_handler (conduit::Node)</li> <li>spin_loop (conduit::Node)</li> <li>spin_subscription (conduit::Node)</li> <li>stop (conduit::Node)</li> <li>subscribe (conduit::Node)</li> <li>ShmRegion (conduit::internal::ShmRegion)</li> <li>size (conduit::internal::ShmRegion)</li> <li>Subscriber (conduit::internal::Subscriber, conduit::Subscriber)</li> </ul>"},{"location":"conduit_core/class_member_functions/#t","title":"t","text":"<ul> <li>topic (conduit::internal::Publisher, conduit::internal::Subscriber, conduit::Publisher, conduit::Subscriber)</li> <li>try_read (conduit::internal::RingBufferReader)</li> <li>try_write (conduit::internal::RingBufferWriter)</li> <li>take (conduit::internal::Subscriber, conduit::Subscriber)</li> </ul>"},{"location":"conduit_core/class_member_functions/#u","title":"u","text":"<ul> <li>uninstall_signal_handlers (conduit::Node)</li> <li>unlink (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_member_functions/#v","title":"v","text":"<ul> <li>validate (conduit::Publisher, conduit::Subscriber)</li> </ul>"},{"location":"conduit_core/class_member_functions/#w","title":"w","text":"<ul> <li>wait (conduit::internal::RingBufferReader, conduit::internal::Subscriber, conduit::Subscriber)</li> <li>wait_for (conduit::internal::RingBufferReader, conduit::internal::Subscriber, conduit::Subscriber)</li> <li>wait_until_exists (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_member_functions/#_1","title":"~","text":"<ul> <li>~Node (conduit::Node)</li> <li>~Publisher (conduit::internal::Publisher)</li> <li>~ShmRegion (conduit::internal::ShmRegion)</li> <li>~Subscriber (conduit::internal::Subscriber)</li> </ul>"},{"location":"conduit_core/class_member_variables/","title":"Class Member Variables","text":""},{"location":"conduit_core/class_member_variables/#a","title":"a","text":"<ul> <li>active_node_ (conduit::Node)</li> </ul>"},{"location":"conduit_core/class_member_variables/#b","title":"b","text":"<ul> <li>buffer_ (conduit::Publisher)</li> </ul>"},{"location":"conduit_core/class_member_variables/#c","title":"c","text":"<ul> <li>callback (conduit::Node::Loop, conduit::Node::Subscription)</li> </ul>"},{"location":"conduit_core/class_member_variables/#d","title":"d","text":"<ul> <li>data (conduit::Message, conduit::internal::ReadResult, conduit::TypedMessage)</li> <li>depth (conduit::PublisherOptions)</li> <li>data_ (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_member_variables/#f","title":"f","text":"<ul> <li>futex_word (conduit::internal::RingBufferHeader)</li> </ul>"},{"location":"conduit_core/class_member_variables/#h","title":"h","text":"<ul> <li>header_ (conduit::internal::RingBufferReader, conduit::internal::RingBufferWriter)</li> </ul>"},{"location":"conduit_core/class_member_variables/#i","title":"i","text":"<ul> <li>impl_ (conduit::Publisher, conduit::Subscriber)</li> </ul>"},{"location":"conduit_core/class_member_variables/#l","title":"l","text":"<ul> <li>loops_ (conduit::Node)</li> </ul>"},{"location":"conduit_core/class_member_variables/#m","title":"m","text":"<ul> <li>max_message_size (conduit::PublisherOptions)</li> <li>max_message_size_ (conduit::internal::Publisher)</li> <li>max_subscribers (conduit::internal::RingBufferHeader)</li> </ul>"},{"location":"conduit_core/class_member_variables/#n","title":"n","text":"<ul> <li>name_ (conduit::internal::ShmRegion)</li> </ul>"},{"location":"conduit_core/class_member_variables/#p","title":"p","text":"<ul> <li>padding0 (conduit::internal::RingBufferHeader)</li> <li>period (conduit::Node::Loop)</li> </ul>"},{"location":"conduit_core/class_member_variables/#r","title":"r","text":"<ul> <li>running_ (conduit::Node)</li> <li>read_idx (conduit::internal::RingBufferHeader)</li> <li>reader_ (conduit::internal::Subscriber)</li> <li>rate_hz (conduit::Node::Loop)</li> </ul>"},{"location":"conduit_core/class_member_variables/#s","title":"s","text":"<ul> <li>sequence (conduit::Message, conduit::internal::ReadResult, conduit::TypedMessage)</li> <li>size (conduit::Message, conduit::internal::ReadResult)</li> <li>subscriptions_ (conduit::Node)</li> <li>shm_ (conduit::internal::Publisher, conduit::internal::Subscriber)</li> <li>slot_count (conduit::internal::RingBufferConfig, conduit::internal::RingBufferHeader)</li> <li>slot_size (conduit::internal::RingBufferConfig, conduit::internal::RingBufferHeader)</li> <li>subscriber_mask (conduit::internal::RingBufferHeader)</li> <li>slot_count_mask_ (conduit::internal::RingBufferReader, conduit::internal::RingBufferWriter)</li> <li>slot_size_ (conduit::internal::RingBufferReader, conduit::internal::RingBufferWriter)</li> <li>slots_ (conduit::internal::RingBufferReader, conduit::internal::RingBufferWriter)</li> <li>slot_count_ (conduit::internal::RingBufferWriter)</li> <li>size_ (conduit::internal::ShmRegion)</li> <li>slot_ (conduit::internal::Subscriber)</li> <li>subscriber (conduit::Node::Subscription)</li> </ul>"},{"location":"conduit_core/class_member_variables/#t","title":"t","text":"<ul> <li>timestamp_ns (conduit::Message, conduit::internal::ReadResult, conduit::TypedMessage)</li> <li>topic_ (conduit::internal::Publisher, conduit::internal::Subscriber)</li> <li>thread (conduit::Node::Loop, conduit::Node::Subscription)</li> <li>topic (conduit::Node::Subscription)</li> </ul>"},{"location":"conduit_core/class_member_variables/#v","title":"v","text":"<ul> <li>value (conduit::internal::AlignedAtomicU64)</li> </ul>"},{"location":"conduit_core/class_member_variables/#w","title":"w","text":"<ul> <li>writer_ (conduit::internal::Publisher)</li> <li>write_idx (conduit::internal::RingBufferHeader)</li> </ul>"},{"location":"conduit_core/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"conduit_core/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"conduit_core/namespace_members/","title":"Namespace Members","text":""},{"location":"conduit_core/namespace_members/#c","title":"c","text":"<ul> <li>CACHE_LINE_SIZE (conduit::internal)</li> <li>calculate_region_size (conduit::internal)</li> </ul>"},{"location":"conduit_core/namespace_members/#d","title":"d","text":"<ul> <li>debug (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_members/#e","title":"e","text":"<ul> <li>error (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_members/#f","title":"f","text":"<ul> <li>futex_wait (conduit::internal)</li> <li>futex_wake (conduit::internal)</li> <li>futex_wake_all (conduit::internal)</li> </ul>"},{"location":"conduit_core/namespace_members/#g","title":"g","text":"<ul> <li>get_timestamp_ns (conduit::internal)</li> <li>get_level (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_members/#i","title":"i","text":"<ul> <li>is_power_of_two (conduit::internal)</li> <li>info (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_members/#l","title":"l","text":"<ul> <li>Level (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_members/#m","title":"m","text":"<ul> <li>MAX_SUBSCRIBERS (conduit::internal)</li> </ul>"},{"location":"conduit_core/namespace_members/#s","title":"s","text":"<ul> <li>SLOT_HEADER_SIZE (conduit::internal)</li> <li>set_level (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_members/#w","title":"w","text":"<ul> <li>warn (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"conduit_core/namespace_member_functions/#c","title":"c","text":"<ul> <li>calculate_region_size (conduit::internal)</li> </ul>"},{"location":"conduit_core/namespace_member_functions/#d","title":"d","text":"<ul> <li>debug (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_member_functions/#e","title":"e","text":"<ul> <li>error (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_member_functions/#f","title":"f","text":"<ul> <li>futex_wait (conduit::internal)</li> <li>futex_wake (conduit::internal)</li> <li>futex_wake_all (conduit::internal)</li> </ul>"},{"location":"conduit_core/namespace_member_functions/#g","title":"g","text":"<ul> <li>get_timestamp_ns (conduit::internal)</li> <li>get_level (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_member_functions/#i","title":"i","text":"<ul> <li>is_power_of_two (conduit::internal)</li> <li>info (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_member_functions/#s","title":"s","text":"<ul> <li>set_level (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_member_functions/#w","title":"w","text":"<ul> <li>warn (conduit::log)</li> </ul>"},{"location":"conduit_core/namespace_member_variables/","title":"Namespace Member Variables","text":""},{"location":"conduit_core/namespace_member_variables/#c","title":"c","text":"<ul> <li>CACHE_LINE_SIZE (conduit::internal)</li> </ul>"},{"location":"conduit_core/namespace_member_variables/#m","title":"m","text":"<ul> <li>MAX_SUBSCRIBERS (conduit::internal)</li> </ul>"},{"location":"conduit_core/namespace_member_variables/#s","title":"s","text":"<ul> <li>SLOT_HEADER_SIZE (conduit::internal)</li> </ul>"},{"location":"conduit_core/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"conduit_core/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"conduit_core/namespace_member_enums/#l","title":"l","text":"<ul> <li>Level (conduit::log)</li> </ul>"},{"location":"conduit_core/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"conduit_core/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"conduit_core/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"conduit_core/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"conduit_types/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace conduit <ul> <li>struct Bool Fixed-size boolean message type. </li> <li>struct Double Fixed-size double-precision floating point message type. </li> <li>struct FixedMessageType Base class for fixed-size, trivially copyable message types. </li> <li>struct Header Common message header with timestamp and coordinate frame. </li> <li>struct Imu Inertial Measurement Unit data (orientation, angular velocity, linear acceleration). </li> <li>struct Int Fixed-size signed 64-bit integer message type. </li> <li>struct Odometry Odometry message with pose and velocity. </li> <li>struct Orientation Quaternion orientation (x, y, z, w) with Euler angle conversions. </li> <li>struct Pose2D 2D pose with position and orientation. </li> <li>struct Pose3D 3D pose with position and orientation. </li> <li>class ReadBuffer Sequential binary reader for deserializing message fields. </li> <li>struct Time Fixed-size timestamp message type. </li> <li>struct Twist Linear and angular velocity in 3D. </li> <li>struct Uint Fixed-size unsigned 64-bit integer message type. </li> <li>class VariableMessageType Base class for variable-size messages requiring serialization. </li> <li>struct Vec2 Fixed-size 2D vector message type. </li> <li>struct Vec3 Fixed-size 3D vector message type. </li> <li>class WriteBuffer Sequential binary writer for serializing message fields. </li> <li>namespace detail </li> </ul> </li> </ul>"},{"location":"conduit_types/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir packages <ul> <li>dir conduit_types <ul> <li>dir include <ul> <li>dir conduit_types <ul> <li>file buffer.hpp </li> <li>file fixed_message_type.hpp Base class and compile-time validation for fixed-size messages. </li> <li>file header.hpp </li> <li>dir derived <ul> <li>file imu.hpp </li> <li>file odometry.hpp </li> <li>file orientation.hpp </li> <li>file pose2d.hpp </li> <li>file pose3d.hpp </li> <li>file twist.hpp </li> </ul> </li> <li>dir primitives <ul> <li>file bool.hpp </li> <li>file double.hpp </li> <li>file int.hpp </li> <li>file time.hpp </li> <li>file uint.hpp </li> <li>file vec2.hpp </li> <li>file vec3.hpp </li> </ul> </li> <li>file variable_message_type.hpp Base class and compile-time validation for variable-size messages. </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"conduit_types/namespaceconduit/","title":"Namespace conduit","text":"<p>Namespace List &gt; conduit</p>"},{"location":"conduit_types/namespaceconduit/#namespaces","title":"Namespaces","text":"Type Name namespace detail"},{"location":"conduit_types/namespaceconduit/#classes","title":"Classes","text":"Type Name struct Bool Fixed-size boolean message type. struct Double Fixed-size double-precision floating point message type. struct FixedMessageType Base class for fixed-size, trivially copyable message types. struct Header Common message header with timestamp and coordinate frame. struct Imu Inertial Measurement Unit data (orientation, angular velocity, linear acceleration). struct Int Fixed-size signed 64-bit integer message type. struct Odometry Odometry message with pose and velocity. struct Orientation Quaternion orientation (x, y, z, w) with Euler angle conversions. struct Pose2D 2D pose with position and orientation. struct Pose3D 3D pose with position and orientation. class ReadBuffer Sequential binary reader for deserializing message fields. struct Time Fixed-size timestamp message type. struct Twist Linear and angular velocity in 3D. struct Uint Fixed-size unsigned 64-bit integer message type. class VariableMessageType Base class for variable-size messages requiring serialization. struct Vec2 Fixed-size 2D vector message type. struct Vec3 Fixed-size 3D vector message type. class WriteBuffer Sequential binary writer for serializing message fields."},{"location":"conduit_types/namespaceconduit/#public-types","title":"Public Types","text":"Type Name enum EulerOrder Euler angle rotation order."},{"location":"conduit_types/namespaceconduit/#public-functions","title":"Public Functions","text":"Type Name void set_frame (char(&amp;) dst, const char * src) Safely copy a frame string into a Header frame field. constexpr void validate_fixed_message_type () Compile-time validation that T is a valid fixed message type. constexpr void validate_variable_message_type () Compile-time validation that T is a valid variable message type."},{"location":"conduit_types/namespaceconduit/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"conduit_types/namespaceconduit/#enum-eulerorder","title":"enum EulerOrder","text":"<p>Euler angle rotation order. <pre><code>enum conduit::EulerOrder {\n    ZYX,\n    XYZ\n};\n</code></pre></p>"},{"location":"conduit_types/namespaceconduit/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_types/namespaceconduit/#function-set_frame","title":"function set_frame","text":"<p>Safely copy a frame string into a Header frame field. <pre><code>inline void conduit::set_frame (\n    char(&amp;) dst,\n    const char * src\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>dst</code> Destination frame array (64 bytes, will be null-terminated). </li> <li><code>src</code> Source null-terminated string. </li> </ul>"},{"location":"conduit_types/namespaceconduit/#function-validate_fixed_message_type","title":"function validate_fixed_message_type","text":"<p>Compile-time validation that T is a valid fixed message type. <pre><code>template&lt;typename T&gt;\nconstexpr void conduit::validate_fixed_message_type () \n</code></pre></p> <p>Checks that T derives from FixedMessageType, is trivially copyable, is standard layout, and is non-empty.</p> <p>Template parameters:</p> <ul> <li><code>T</code> The type to validate. </li> </ul>"},{"location":"conduit_types/namespaceconduit/#function-validate_variable_message_type","title":"function validate_variable_message_type","text":"<p>Compile-time validation that T is a valid variable message type. <pre><code>template&lt;typename T&gt;\nconstexpr void conduit::validate_variable_message_type () \n</code></pre></p> <p>Checks that T derives from VariableMessageType, is not trivially copyable, and provides a static <code>T deserialize(const uint8_t*, size_t)</code> method.</p> <p>Template parameters:</p> <ul> <li><code>T</code> The type to validate. </li> </ul> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/buffer.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Bool/","title":"Struct conduit::Bool","text":"<p>ClassList &gt; conduit &gt; Bool</p> <p>Fixed-size boolean message type. </p> <ul> <li><code>#include &lt;bool.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Bool/#public-attributes","title":"Public Attributes","text":"Type Name bool value Boolean value."},{"location":"conduit_types/structconduit_1_1Bool/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Bool/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Bool/#variable-value","title":"variable value","text":"<p>Boolean value. <pre><code>bool conduit::Bool::value;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/bool.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Double/","title":"Struct conduit::Double","text":"<p>ClassList &gt; conduit &gt; Double</p> <p>Fixed-size double-precision floating point message type. </p> <ul> <li><code>#include &lt;double.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Double/#public-attributes","title":"Public Attributes","text":"Type Name double value Double-precision value."},{"location":"conduit_types/structconduit_1_1Double/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Double/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Double/#variable-value","title":"variable value","text":"<p>Double-precision value. <pre><code>double conduit::Double::value;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/double.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1FixedMessageType/","title":"Struct conduit::FixedMessageType","text":"<p>ClassList &gt; conduit &gt; FixedMessageType</p> <p>Base class for fixed-size, trivially copyable message types. More...</p> <ul> <li><code>#include &lt;fixed_message_type.hpp&gt;</code></li> </ul> <p>Inherited by the following classes: conduit::Bool,  conduit::Double,  conduit::Imu,  conduit::Int,  conduit::Odometry,  conduit::Orientation,  conduit::Pose2D,  conduit::Pose3D,  conduit::Time,  conduit::Twist,  conduit::Uint,  conduit::Vec2,  conduit::Vec3</p>"},{"location":"conduit_types/structconduit_1_1FixedMessageType/#protected-functions","title":"Protected Functions","text":"Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1FixedMessageType/#detailed-description","title":"Detailed Description","text":"<p>Derive from this to create messages that are transmitted via zero-copy memcpy. The type must be trivially copyable and standard layout.</p> <p>See also: validate_fixed_message_type </p>"},{"location":"conduit_types/structconduit_1_1FixedMessageType/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"conduit_types/structconduit_1_1FixedMessageType/#function-fixedmessagetype","title":"function FixedMessageType","text":"<pre><code>conduit::FixedMessageType::FixedMessageType () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/fixed_message_type.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Header/","title":"Struct conduit::Header","text":"<p>ClassList &gt; conduit &gt; Header</p> <p>Common message header with timestamp and coordinate frame. </p> <ul> <li><code>#include &lt;header.hpp&gt;</code></li> </ul>"},{"location":"conduit_types/structconduit_1_1Header/#public-attributes","title":"Public Attributes","text":"Type Name char frame Coordinate frame identifier (null-terminated). uint64_t timestamp_ns Timestamp in nanoseconds."},{"location":"conduit_types/structconduit_1_1Header/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Header/#variable-frame","title":"variable frame","text":"<p>Coordinate frame identifier (null-terminated). <pre><code>char conduit::Header::frame[64];\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Header/#variable-timestamp_ns","title":"variable timestamp_ns","text":"<p>Timestamp in nanoseconds. <pre><code>uint64_t conduit::Header::timestamp_ns;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/header.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Imu/","title":"Struct conduit::Imu","text":"<p>ClassList &gt; conduit &gt; Imu</p> <p>Inertial Measurement Unit data (orientation, angular velocity, linear acceleration). </p> <ul> <li><code>#include &lt;imu.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Imu/#public-attributes","title":"Public Attributes","text":"Type Name Vec3 angular_velocity Angular velocity (rad/s). Header header Timestamp and coordinate frame. Vec3 linear_acceleration Linear acceleration (m/s^2). Orientation orientation Quaternion orientation estimate."},{"location":"conduit_types/structconduit_1_1Imu/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Imu/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Imu/#variable-angular_velocity","title":"variable angular_velocity","text":"<p>Angular velocity (rad/s). <pre><code>Vec3 conduit::Imu::angular_velocity;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Imu/#variable-header","title":"variable header","text":"<p>Timestamp and coordinate frame. <pre><code>Header conduit::Imu::header;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Imu/#variable-linear_acceleration","title":"variable linear_acceleration","text":"<p>Linear acceleration (m/s^2). <pre><code>Vec3 conduit::Imu::linear_acceleration;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Imu/#variable-orientation","title":"variable orientation","text":"<p>Quaternion orientation estimate. <pre><code>Orientation conduit::Imu::orientation;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/imu.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Int/","title":"Struct conduit::Int","text":"<p>ClassList &gt; conduit &gt; Int</p> <p>Fixed-size signed 64-bit integer message type. </p> <ul> <li><code>#include &lt;int.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Int/#public-attributes","title":"Public Attributes","text":"Type Name int64_t value Signed integer value."},{"location":"conduit_types/structconduit_1_1Int/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Int/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Int/#variable-value","title":"variable value","text":"<p>Signed integer value. <pre><code>int64_t conduit::Int::value;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/int.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Odometry/","title":"Struct conduit::Odometry","text":"<p>ClassList &gt; conduit &gt; Odometry</p> <p>Odometry message with pose and velocity.</p> <ul> <li><code>#include &lt;odometry.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Odometry/#public-attributes","title":"Public Attributes","text":"Type Name Vec3 angular_velocity Angular velocity (rad/s). char child_frame Child coordinate frame (null-terminated). Header header Timestamp and coordinate frame. Vec3 linear_velocity Linear velocity (m/s). Pose3D pose 3D pose estimate."},{"location":"conduit_types/structconduit_1_1Odometry/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Odometry/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Odometry/#variable-angular_velocity","title":"variable angular_velocity","text":"<p>Angular velocity (rad/s). <pre><code>Vec3 conduit::Odometry::angular_velocity;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Odometry/#variable-child_frame","title":"variable child_frame","text":"<p>Child coordinate frame (null-terminated). <pre><code>char conduit::Odometry::child_frame[64];\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Odometry/#variable-header","title":"variable header","text":"<p>Timestamp and coordinate frame. <pre><code>Header conduit::Odometry::header;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Odometry/#variable-linear_velocity","title":"variable linear_velocity","text":"<p>Linear velocity (m/s). <pre><code>Vec3 conduit::Odometry::linear_velocity;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Odometry/#variable-pose","title":"variable pose","text":"<p>3D pose estimate. <pre><code>Pose3D conduit::Odometry::pose;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/odometry.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Orientation/","title":"Struct conduit::Orientation","text":"<p>ClassList &gt; conduit &gt; Orientation</p> <p>Quaternion orientation (x, y, z, w) with Euler angle conversions. More...</p> <ul> <li><code>#include &lt;orientation.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Orientation/#public-attributes","title":"Public Attributes","text":"Type Name double w Quaternion W (scalar) component. double x Quaternion X component. double y Quaternion Y component. double z Quaternion Z component."},{"location":"conduit_types/structconduit_1_1Orientation/#public-functions","title":"Public Functions","text":"Type Name Vec3 to_euler (EulerOrder order=EulerOrder::ZYX) constConvert quaternion to Euler angles. double to_yaw () constExtract the yaw angle from the quaternion (convenience for 2D)."},{"location":"conduit_types/structconduit_1_1Orientation/#public-static-functions","title":"Public Static Functions","text":"Type Name Orientation from_euler (double roll, double pitch, double yaw, EulerOrder order=EulerOrder::ZYX) Create a quaternion from Euler angles (roll, pitch, yaw). Orientation from_yaw (double yaw) Create a quaternion from a yaw-only rotation (convenience for 2D)."},{"location":"conduit_types/structconduit_1_1Orientation/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Orientation/#detailed-description","title":"Detailed Description","text":"<p>Represents a 3D rotation as a unit quaternion. Provides factory methods for constructing from Euler angles and extracting them back. </p>"},{"location":"conduit_types/structconduit_1_1Orientation/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Orientation/#variable-w","title":"variable w","text":"<p>Quaternion W (scalar) component. <pre><code>double conduit::Orientation::w;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Orientation/#variable-x","title":"variable x","text":"<p>Quaternion X component. <pre><code>double conduit::Orientation::x;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Orientation/#variable-y","title":"variable y","text":"<p>Quaternion Y component. <pre><code>double conduit::Orientation::y;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Orientation/#variable-z","title":"variable z","text":"<p>Quaternion Z component. <pre><code>double conduit::Orientation::z;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Orientation/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_types/structconduit_1_1Orientation/#function-to_euler","title":"function to_euler","text":"<p>Convert quaternion to Euler angles. <pre><code>inline Vec3 conduit::Orientation::to_euler (\n    EulerOrder order=EulerOrder::ZYX\n) const\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>order</code> Euler angle convention (default ZYX). </li> </ul> <p>Returns:</p> <p>Vec3 with x=roll, y=pitch, z=yaw in radians. </p>"},{"location":"conduit_types/structconduit_1_1Orientation/#function-to_yaw","title":"function to_yaw","text":"<p>Extract the yaw angle from the quaternion (convenience for 2D). <pre><code>inline double conduit::Orientation::to_yaw () const\n</code></pre></p> <p>Returns:</p> <p>Yaw angle in radians. </p>"},{"location":"conduit_types/structconduit_1_1Orientation/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"conduit_types/structconduit_1_1Orientation/#function-from_euler","title":"function from_euler","text":"<p>Create a quaternion from Euler angles (roll, pitch, yaw). <pre><code>static inline Orientation conduit::Orientation::from_euler (\n    double roll,\n    double pitch,\n    double yaw,\n    EulerOrder order=EulerOrder::ZYX\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>roll</code> Rotation about X axis in radians. </li> <li><code>pitch</code> Rotation about Y axis in radians. </li> <li><code>yaw</code> Rotation about Z axis in radians. </li> <li><code>order</code> Euler angle convention (default ZYX). </li> </ul> <p>Returns:</p> <p>Unit quaternion representing the rotation. </p>"},{"location":"conduit_types/structconduit_1_1Orientation/#function-from_yaw","title":"function from_yaw","text":"<p>Create a quaternion from a yaw-only rotation (convenience for 2D). <pre><code>static inline Orientation conduit::Orientation::from_yaw (\n    double yaw\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>yaw</code> Rotation about Z axis in radians. </li> </ul> <p>Returns:</p> <p>Unit quaternion representing the rotation. </p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/orientation.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Pose2D/","title":"Struct conduit::Pose2D","text":"<p>ClassList &gt; conduit &gt; Pose2D</p> <p>2D pose with position and orientation. </p> <ul> <li><code>#include &lt;pose2d.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Pose2D/#public-attributes","title":"Public Attributes","text":"Type Name Header header Timestamp and coordinate frame. Orientation orientation Quaternion orientation (typically yaw-only for 2D). Vec2 position 2D position (x, y)."},{"location":"conduit_types/structconduit_1_1Pose2D/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Pose2D/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Pose2D/#variable-header","title":"variable header","text":"<p>Timestamp and coordinate frame. <pre><code>Header conduit::Pose2D::header;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Pose2D/#variable-orientation","title":"variable orientation","text":"<p>Quaternion orientation (typically yaw-only for 2D). <pre><code>Orientation conduit::Pose2D::orientation;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Pose2D/#variable-position","title":"variable position","text":"<p>2D position (x, y). <pre><code>Vec2 conduit::Pose2D::position;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/pose2d.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Pose3D/","title":"Struct conduit::Pose3D","text":"<p>ClassList &gt; conduit &gt; Pose3D</p> <p>3D pose with position and orientation. </p> <ul> <li><code>#include &lt;pose3d.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Pose3D/#public-attributes","title":"Public Attributes","text":"Type Name Header header Timestamp and coordinate frame. Orientation orientation Quaternion orientation. Vec3 position 3D position (x, y, z)."},{"location":"conduit_types/structconduit_1_1Pose3D/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Pose3D/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Pose3D/#variable-header","title":"variable header","text":"<p>Timestamp and coordinate frame. <pre><code>Header conduit::Pose3D::header;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Pose3D/#variable-orientation","title":"variable orientation","text":"<p>Quaternion orientation. <pre><code>Orientation conduit::Pose3D::orientation;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Pose3D/#variable-position","title":"variable position","text":"<p>3D position (x, y, z). <pre><code>Vec3 conduit::Pose3D::position;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/pose3d.hpp</code></p>"},{"location":"conduit_types/classconduit_1_1ReadBuffer/","title":"Class conduit::ReadBuffer","text":"<p>ClassList &gt; conduit &gt; ReadBuffer</p> <p>Sequential binary reader for deserializing message fields. More...</p> <ul> <li><code>#include &lt;buffer.hpp&gt;</code></li> </ul>"},{"location":"conduit_types/classconduit_1_1ReadBuffer/#public-functions","title":"Public Functions","text":"Type Name ReadBuffer (const uint8_t * data, size_t size) Construct a read buffer over the given data. T read () Read the next value from the buffer."},{"location":"conduit_types/classconduit_1_1ReadBuffer/#detailed-description","title":"Detailed Description","text":"<p>Reads values contiguously from a byte buffer. Strings are read as length-prefixed (uint32_t). Trivially copyable types are read via memcpy.</p> <p>See also: WriteBuffer </p>"},{"location":"conduit_types/classconduit_1_1ReadBuffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_types/classconduit_1_1ReadBuffer/#function-readbuffer","title":"function ReadBuffer","text":"<p>Construct a read buffer over the given data. <pre><code>inline conduit::ReadBuffer::ReadBuffer (\n    const uint8_t * data,\n    size_t size\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>data</code> Pointer to the input buffer. </li> <li><code>size</code> Total buffer size in bytes (used for bounds context). </li> </ul>"},{"location":"conduit_types/classconduit_1_1ReadBuffer/#function-read","title":"function read","text":"<p>Read the next value from the buffer. <pre><code>template&lt;typename T&gt;\ninline T conduit::ReadBuffer::read () \n</code></pre></p> <p>For std::string, reads a uint32_t length prefix followed by that many characters. For trivially copyable types, reads sizeof(T) bytes.</p> <p>Template parameters:</p> <ul> <li><code>T</code> Type to read (std::string or trivially copyable). </li> </ul> <p>Returns:</p> <p>The deserialized value. </p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/buffer.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Time/","title":"Struct conduit::Time","text":"<p>ClassList &gt; conduit &gt; Time</p> <p>Fixed-size timestamp message type. </p> <ul> <li><code>#include &lt;time.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Time/#public-attributes","title":"Public Attributes","text":"Type Name uint64_t nanoseconds Time in nanoseconds."},{"location":"conduit_types/structconduit_1_1Time/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Time/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Time/#variable-nanoseconds","title":"variable nanoseconds","text":"<p>Time in nanoseconds. <pre><code>uint64_t conduit::Time::nanoseconds;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/time.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Twist/","title":"Struct conduit::Twist","text":"<p>ClassList &gt; conduit &gt; Twist</p> <p>Linear and angular velocity in 3D. </p> <ul> <li><code>#include &lt;twist.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Twist/#public-attributes","title":"Public Attributes","text":"Type Name Vec3 angular Angular velocity (rad/s) in x, y, z. Header header Timestamp and coordinate frame. Vec3 linear Linear velocity (m/s) in x, y, z."},{"location":"conduit_types/structconduit_1_1Twist/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Twist/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Twist/#variable-angular","title":"variable angular","text":"<p>Angular velocity (rad/s) in x, y, z. <pre><code>Vec3 conduit::Twist::angular;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Twist/#variable-header","title":"variable header","text":"<p>Timestamp and coordinate frame. <pre><code>Header conduit::Twist::header;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Twist/#variable-linear","title":"variable linear","text":"<p>Linear velocity (m/s) in x, y, z. <pre><code>Vec3 conduit::Twist::linear;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/twist.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Uint/","title":"Struct conduit::Uint","text":"<p>ClassList &gt; conduit &gt; Uint</p> <p>Fixed-size unsigned 64-bit integer message type. </p> <ul> <li><code>#include &lt;uint.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Uint/#public-attributes","title":"Public Attributes","text":"Type Name uint64_t value Unsigned integer value."},{"location":"conduit_types/structconduit_1_1Uint/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Uint/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Uint/#variable-value","title":"variable value","text":"<p>Unsigned integer value. <pre><code>uint64_t conduit::Uint::value;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/uint.hpp</code></p>"},{"location":"conduit_types/classconduit_1_1VariableMessageType/","title":"Class conduit::VariableMessageType","text":"<p>ClassList &gt; conduit &gt; VariableMessageType</p> <p>Base class for variable-size messages requiring serialization. More...</p> <ul> <li><code>#include &lt;variable_message_type.hpp&gt;</code></li> </ul>"},{"location":"conduit_types/classconduit_1_1VariableMessageType/#public-functions","title":"Public Functions","text":"Type Name virtual void serialize (uint8_t * buffer) const = 0Serialize the message into a pre-allocated buffer. virtual size_t serialized_size () const = 0Compute the serialized size in bytes. virtual ~VariableMessageType () = default"},{"location":"conduit_types/classconduit_1_1VariableMessageType/#protected-functions","title":"Protected Functions","text":"Type Name VariableMessageType () = default"},{"location":"conduit_types/classconduit_1_1VariableMessageType/#detailed-description","title":"Detailed Description","text":"<p>Derive from this to create messages with dynamic-size fields (e.g. strings). Subclasses must implement serialized_size(), serialize(), and a static deserialize() factory method.</p> <p>See also: validate_variable_message_type, WriteBuffer, ReadBuffer </p>"},{"location":"conduit_types/classconduit_1_1VariableMessageType/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_types/classconduit_1_1VariableMessageType/#function-serialize","title":"function serialize","text":"<p>Serialize the message into a pre-allocated buffer. <pre><code>virtual void conduit::VariableMessageType::serialize (\n    uint8_t * buffer\n) const = 0\n</code></pre></p> <p>Parameters:</p> <ul> <li><code>buffer</code> Output buffer (must have at least serialized_size() bytes). </li> </ul>"},{"location":"conduit_types/classconduit_1_1VariableMessageType/#function-serialized_size","title":"function serialized_size","text":"<p>Compute the serialized size in bytes. <pre><code>virtual size_t conduit::VariableMessageType::serialized_size () const = 0\n</code></pre></p> <p>Returns:</p> <p>Number of bytes needed for serialize(). </p>"},{"location":"conduit_types/classconduit_1_1VariableMessageType/#function-variablemessagetype","title":"function ~VariableMessageType","text":"<pre><code>virtual conduit::VariableMessageType::~VariableMessageType () = default\n</code></pre>"},{"location":"conduit_types/classconduit_1_1VariableMessageType/#protected-functions-documentation","title":"Protected Functions Documentation","text":""},{"location":"conduit_types/classconduit_1_1VariableMessageType/#function-variablemessagetype_1","title":"function VariableMessageType","text":"<pre><code>conduit::VariableMessageType::VariableMessageType () = default\n</code></pre> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/variable_message_type.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Vec2/","title":"Struct conduit::Vec2","text":"<p>ClassList &gt; conduit &gt; Vec2</p> <p>Fixed-size 2D vector message type. </p> <ul> <li><code>#include &lt;vec2.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Vec2/#public-attributes","title":"Public Attributes","text":"Type Name double x X component. double y Y component."},{"location":"conduit_types/structconduit_1_1Vec2/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Vec2/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Vec2/#variable-x","title":"variable x","text":"<p>X component. <pre><code>double conduit::Vec2::x;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Vec2/#variable-y","title":"variable y","text":"<p>Y component. <pre><code>double conduit::Vec2::y;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/vec2.hpp</code></p>"},{"location":"conduit_types/structconduit_1_1Vec3/","title":"Struct conduit::Vec3","text":"<p>ClassList &gt; conduit &gt; Vec3</p> <p>Fixed-size 3D vector message type. </p> <ul> <li><code>#include &lt;vec3.hpp&gt;</code></li> </ul> <p>Inherits the following classes: conduit::FixedMessageType</p>"},{"location":"conduit_types/structconduit_1_1Vec3/#public-attributes","title":"Public Attributes","text":"Type Name double x X component. double y Y component. double z Z component."},{"location":"conduit_types/structconduit_1_1Vec3/#protected-functions-inherited-from-conduitfixedmessagetype","title":"Protected Functions inherited from conduit::FixedMessageType","text":"<p>See conduit::FixedMessageType</p> Type Name FixedMessageType () = default"},{"location":"conduit_types/structconduit_1_1Vec3/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_types/structconduit_1_1Vec3/#variable-x","title":"variable x","text":"<p>X component. <pre><code>double conduit::Vec3::x;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Vec3/#variable-y","title":"variable y","text":"<p>Y component. <pre><code>double conduit::Vec3::y;\n</code></pre></p>"},{"location":"conduit_types/structconduit_1_1Vec3/#variable-z","title":"variable z","text":"<p>Z component. <pre><code>double conduit::Vec3::z;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/vec3.hpp</code></p>"},{"location":"conduit_types/classconduit_1_1WriteBuffer/","title":"Class conduit::WriteBuffer","text":"<p>ClassList &gt; conduit &gt; WriteBuffer</p> <p>Sequential binary writer for serializing message fields. More...</p> <ul> <li><code>#include &lt;buffer.hpp&gt;</code></li> </ul>"},{"location":"conduit_types/classconduit_1_1WriteBuffer/#public-functions","title":"Public Functions","text":"Type Name WriteBuffer (uint8_t * data) Construct a write buffer starting at the given pointer. void write (const std::string &amp; s) Write a length-prefixed string. void write (const T &amp; val) Write a trivially copyable value."},{"location":"conduit_types/classconduit_1_1WriteBuffer/#public-static-functions","title":"Public Static Functions","text":"Type Name size_t size_of (const std::string &amp; s) Compute the serialized size of a string (4-byte length prefix + content). constexpr size_t size_of (const T &amp;) Compute the serialized size of a trivially copyable value."},{"location":"conduit_types/classconduit_1_1WriteBuffer/#detailed-description","title":"Detailed Description","text":"<p>Writes values contiguously into a pre-allocated byte buffer. Strings are length-prefixed (uint32_t). Trivially copyable types are written via memcpy.</p> <p>See also: ReadBuffer </p>"},{"location":"conduit_types/classconduit_1_1WriteBuffer/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_types/classconduit_1_1WriteBuffer/#function-writebuffer","title":"function WriteBuffer","text":"<p>Construct a write buffer starting at the given pointer. <pre><code>inline explicit conduit::WriteBuffer::WriteBuffer (\n    uint8_t * data\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>data</code> Pointer to the output buffer. </li> </ul>"},{"location":"conduit_types/classconduit_1_1WriteBuffer/#function-write-12","title":"function write [1/2]","text":"<p>Write a length-prefixed string. <pre><code>inline void conduit::WriteBuffer::write (\n    const std::string &amp; s\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>s</code> The string to write. </li> </ul>"},{"location":"conduit_types/classconduit_1_1WriteBuffer/#function-write-22","title":"function write [2/2]","text":"<p>Write a trivially copyable value. <pre><code>template&lt;typename T, std::enable_if_t&lt; std::is_trivially_copyable_v&lt; T &gt;, int &gt;&gt;\ninline void conduit::WriteBuffer::write (\n    const T &amp; val\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> Value type (must be trivially copyable). </li> </ul> <p>Parameters:</p> <ul> <li><code>val</code> The value to write. </li> </ul>"},{"location":"conduit_types/classconduit_1_1WriteBuffer/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"conduit_types/classconduit_1_1WriteBuffer/#function-size_of-12","title":"function size_of [1/2]","text":"<p>Compute the serialized size of a string (4-byte length prefix + content). <pre><code>static inline size_t conduit::WriteBuffer::size_of (\n    const std::string &amp; s\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>s</code> The string. </li> </ul> <p>Returns:</p> <p>Size in bytes. </p>"},{"location":"conduit_types/classconduit_1_1WriteBuffer/#function-size_of-22","title":"function size_of [2/2]","text":"<p>Compute the serialized size of a trivially copyable value. <pre><code>template&lt;typename T, std::enable_if_t&lt; std::is_trivially_copyable_v&lt; T &gt;, int &gt;&gt;\nstatic inline constexpr size_t conduit::WriteBuffer::size_of (\n    const T &amp;\n) \n</code></pre></p> <p>Template parameters:</p> <ul> <li><code>T</code> Value type. </li> </ul> <p>Returns:</p> <p>sizeof(T). </p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/buffer.hpp</code></p>"},{"location":"conduit_types/namespaceconduit_1_1detail/","title":"Namespace conduit::detail","text":"<p>Namespace List &gt; conduit &gt; detail</p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/variable_message_type.hpp</code></p>"},{"location":"conduit_types/dir_93501a11e921083efbd154e0cdff5f10/","title":"Dir packages","text":"<p>FileList &gt; packages</p>"},{"location":"conduit_types/dir_93501a11e921083efbd154e0cdff5f10/#directories","title":"Directories","text":"Type Name dir conduit_types <p>The documentation for this class was generated from the following file <code>packages/</code></p>"},{"location":"conduit_types/dir_2f8116ad873fa9f4ab4bc95e5e2c7e48/","title":"Dir packages/conduit_types","text":"<p>FileList &gt; conduit_types</p>"},{"location":"conduit_types/dir_2f8116ad873fa9f4ab4bc95e5e2c7e48/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>packages/conduit_types/</code></p>"},{"location":"conduit_types/dir_b494fed11488e6772c8fe9a92fd0e861/","title":"Dir packages/conduit_types/include","text":"<p>FileList &gt; conduit_types &gt; include</p>"},{"location":"conduit_types/dir_b494fed11488e6772c8fe9a92fd0e861/#directories","title":"Directories","text":"Type Name dir conduit_types <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/</code></p>"},{"location":"conduit_types/dir_5c67974ec98d7ff0f95b9e09c6bc682d/","title":"Dir packages/conduit_types/include/conduit_types","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types</p>"},{"location":"conduit_types/dir_5c67974ec98d7ff0f95b9e09c6bc682d/#files","title":"Files","text":"Type Name file buffer.hpp file fixed_message_type.hpp Base class and compile-time validation for fixed-size messages. file header.hpp file variable_message_type.hpp Base class and compile-time validation for variable-size messages."},{"location":"conduit_types/dir_5c67974ec98d7ff0f95b9e09c6bc682d/#directories","title":"Directories","text":"Type Name dir derived dir primitives <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/</code></p>"},{"location":"conduit_types/buffer_8hpp/","title":"File buffer.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; buffer.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"conduit_types/buffer_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/buffer_8hpp/#classes","title":"Classes","text":"Type Name class ReadBuffer Sequential binary reader for deserializing message fields. class WriteBuffer Sequential binary writer for serializing message fields. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/buffer.hpp</code></p>"},{"location":"conduit_types/buffer_8hpp_source/","title":"File buffer.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; buffer.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n#include &lt;string&gt;\n#include &lt;type_traits&gt;\n\nnamespace conduit {\n\nclass WriteBuffer {\npublic:\n    explicit WriteBuffer(uint8_t* data) : ptr_(data) {}\n\n    void write(const std::string&amp; s) {\n        uint32_t len = static_cast&lt;uint32_t&gt;(s.size());\n        std::memcpy(ptr_, &amp;len, sizeof(len));\n        ptr_ += sizeof(len);\n        std::memcpy(ptr_, s.data(), s.size());\n        ptr_ += s.size();\n    }\n\n    template&lt;typename T, std::enable_if_t&lt;std::is_trivially_copyable_v&lt;T&gt;, int&gt; = 0&gt;\n    void write(const T&amp; val) {\n        std::memcpy(ptr_, &amp;val, sizeof(T));\n        ptr_ += sizeof(T);\n    }\n\n    static size_t size_of(const std::string&amp; s) {\n        return sizeof(uint32_t) + s.size();\n    }\n\n    template&lt;typename T, std::enable_if_t&lt;std::is_trivially_copyable_v&lt;T&gt;, int&gt; = 0&gt;\n    static constexpr size_t size_of(const T&amp;) { return sizeof(T); }\n\nprivate:\n    uint8_t* ptr_;\n};\n\nclass ReadBuffer {\npublic:\n    ReadBuffer(const uint8_t* data, size_t size) : ptr_(data) { (void)size; }\n\n    template&lt;typename T&gt;\n    T read() {\n        if constexpr (std::is_same_v&lt;T, std::string&gt;) {\n            uint32_t len;\n            std::memcpy(&amp;len, ptr_, sizeof(len));\n            ptr_ += sizeof(len);\n            std::string s(reinterpret_cast&lt;const char*&gt;(ptr_), len);\n            ptr_ += len;\n            return s;\n        } else {\n            static_assert(std::is_trivially_copyable_v&lt;T&gt;);\n            T val;\n            std::memcpy(&amp;val, ptr_, sizeof(T));\n            ptr_ += sizeof(T);\n            return val;\n        }\n    }\n\nprivate:\n    const uint8_t* ptr_;\n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/fixed__message__type_8hpp/","title":"File fixed_message_type.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; fixed_message_type.hpp</p> <p>Go to the source code of this file</p> <p>Base class and compile-time validation for fixed-size messages. More...</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"conduit_types/fixed__message__type_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/fixed__message__type_8hpp/#classes","title":"Classes","text":"Type Name struct FixedMessageType Base class for fixed-size, trivially copyable message types."},{"location":"conduit_types/fixed__message__type_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Rules for fixed message types: * Derive from FixedMessageType * Must be trivially copyable (no pointers, no std::string, no virtuals) * Must be standard layout * Published via memcpy \u2014 no serialization needed</p> <p>See also: validate_fixed_message_type, VariableMessageType </p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/fixed_message_type.hpp</code></p>"},{"location":"conduit_types/fixed__message__type_8hpp_source/","title":"File fixed_message_type.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; fixed_message_type.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n\n#include &lt;cstddef&gt;\n#include &lt;type_traits&gt;\n\nnamespace conduit {\n\nstruct FixedMessageType {\nprotected:\n    FixedMessageType() = default;\n};\n\ntemplate &lt;typename T&gt;\nconstexpr void validate_fixed_message_type() {\n    static_assert(std::is_base_of_v&lt;FixedMessageType, T&gt;,\n        \"T must derive from FixedMessageType\");\n    static_assert(std::is_trivially_copyable_v&lt;T&gt;,\n        \"T must be trivially copyable (no pointers, strings, or virtual functions)\");\n    static_assert(std::is_standard_layout_v&lt;T&gt;,\n        \"T must be standard layout\");\n    static_assert(sizeof(T) &gt; 0,\n        \"T must not be empty\");\n}\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/header_8hpp/","title":"File header.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; header.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;cstring&gt;</code></li> </ul>"},{"location":"conduit_types/header_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/header_8hpp/#classes","title":"Classes","text":"Type Name struct Header Common message header with timestamp and coordinate frame. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/header.hpp</code></p>"},{"location":"conduit_types/header_8hpp_source/","title":"File header.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; header.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;cstring&gt;\n\nnamespace conduit {\n\nstruct Header {\n    uint64_t timestamp_ns;  \n    char frame[64];         \n};\n\ninline void set_frame(char (&amp;dst)[64], const char* src) {\n    std::strncpy(dst, src, 63);\n    dst[63] = '\\0';\n}\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/dir_6c611f3cf964ed6f858fc2fcf2f339e5/","title":"Dir packages/conduit_types/include/conduit_types/derived","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; derived</p>"},{"location":"conduit_types/dir_6c611f3cf964ed6f858fc2fcf2f339e5/#files","title":"Files","text":"Type Name file imu.hpp file odometry.hpp file orientation.hpp file pose2d.hpp file pose3d.hpp file twist.hpp <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/</code></p>"},{"location":"conduit_types/imu_8hpp/","title":"File imu.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; derived &gt; imu.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/derived/orientation.hpp\"</code></li> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> <li><code>#include \"conduit_types/header.hpp\"</code></li> <li><code>#include \"conduit_types/primitives/vec3.hpp\"</code></li> </ul>"},{"location":"conduit_types/imu_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/imu_8hpp/#classes","title":"Classes","text":"Type Name struct Imu Inertial Measurement Unit data (orientation, angular velocity, linear acceleration). <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/imu.hpp</code></p>"},{"location":"conduit_types/imu_8hpp_source/","title":"File imu.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; derived &gt; imu.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/derived/orientation.hpp\"\n#include \"conduit_types/fixed_message_type.hpp\"\n#include \"conduit_types/header.hpp\"\n#include \"conduit_types/primitives/vec3.hpp\"\n\nnamespace conduit {\n\nstruct Imu : FixedMessageType {\n    Header header;                \n    Orientation orientation;      \n    Vec3 angular_velocity;        \n    Vec3 linear_acceleration;     \n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/odometry_8hpp/","title":"File odometry.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; derived &gt; odometry.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/derived/pose3d.hpp\"</code></li> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> <li><code>#include \"conduit_types/header.hpp\"</code></li> <li><code>#include \"conduit_types/primitives/vec3.hpp\"</code></li> </ul>"},{"location":"conduit_types/odometry_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/odometry_8hpp/#classes","title":"Classes","text":"Type Name struct Odometry Odometry message with pose and velocity. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/odometry.hpp</code></p>"},{"location":"conduit_types/odometry_8hpp_source/","title":"File odometry.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; derived &gt; odometry.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/derived/pose3d.hpp\"\n#include \"conduit_types/fixed_message_type.hpp\"\n#include \"conduit_types/header.hpp\"\n#include \"conduit_types/primitives/vec3.hpp\"\n\nnamespace conduit {\n\nstruct Odometry : FixedMessageType {\n    Header header;              \n    char child_frame[64];       \n    Pose3D pose;                \n    Vec3 linear_velocity;       \n    Vec3 angular_velocity;      \n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/orientation_8hpp/","title":"File orientation.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; derived &gt; orientation.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> <li><code>#include \"conduit_types/primitives/vec3.hpp\"</code></li> <li><code>#include &lt;cmath&gt;</code></li> </ul>"},{"location":"conduit_types/orientation_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/orientation_8hpp/#classes","title":"Classes","text":"Type Name struct Orientation Quaternion orientation (x, y, z, w) with Euler angle conversions. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/orientation.hpp</code></p>"},{"location":"conduit_types/orientation_8hpp_source/","title":"File orientation.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; derived &gt; orientation.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/fixed_message_type.hpp\"\n#include \"conduit_types/primitives/vec3.hpp\"\n\n#include &lt;cmath&gt;\n\nnamespace conduit {\n\nenum class EulerOrder { ZYX, XYZ };\n\nstruct Orientation : FixedMessageType {\n    double x;  \n    double y;  \n    double z;  \n    double w;  \n\n    static Orientation from_euler(double roll, double pitch, double yaw,\n                                  EulerOrder order = EulerOrder::ZYX) {\n        const double cr = std::cos(roll * 0.5), sr = std::sin(roll * 0.5);\n        const double cp = std::cos(pitch * 0.5), sp = std::sin(pitch * 0.5);\n        const double cy = std::cos(yaw * 0.5), sy = std::sin(yaw * 0.5);\n\n        Orientation q{};\n        if (order == EulerOrder::ZYX) {\n            q.w = cr * cp * cy + sr * sp * sy;\n            q.x = sr * cp * cy - cr * sp * sy;\n            q.y = cr * sp * cy + sr * cp * sy;\n            q.z = cr * cp * sy - sr * sp * cy;\n        } else {  // XYZ\n            q.w = cr * cp * cy - sr * sp * sy;\n            q.x = sr * cp * cy + cr * sp * sy;\n            q.y = cr * sp * cy - sr * cp * sy;\n            q.z = cr * cp * sy + sr * sp * cy;\n        }\n        return q;\n    }\n\n    static Orientation from_yaw(double yaw) {\n        Orientation q{};\n        q.z = std::sin(yaw * 0.5);\n        q.w = std::cos(yaw * 0.5);\n        return q;\n    }\n\n    Vec3 to_euler(EulerOrder order = EulerOrder::ZYX) const {\n        Vec3 e{};\n        if (order == EulerOrder::ZYX) {\n            e.x = std::atan2(2.0 * (w * x + y * z), 1.0 - 2.0 * (x * x + y * y));\n            double sp = 2.0 * (w * y - z * x);\n            e.y = std::asin(sp &lt; -1.0 ? -1.0 : (sp &gt; 1.0 ? 1.0 : sp));\n            e.z = std::atan2(2.0 * (w * z + x * y), 1.0 - 2.0 * (y * y + z * z));\n        } else {  // XYZ\n            e.x = std::atan2(2.0 * (w * x - y * z), 1.0 - 2.0 * (x * x + y * y));\n            double sp = 2.0 * (w * y + x * z);\n            e.y = std::asin(sp &lt; -1.0 ? -1.0 : (sp &gt; 1.0 ? 1.0 : sp));\n            e.z = std::atan2(2.0 * (w * z - x * y), 1.0 - 2.0 * (y * y + z * z));\n        }\n        return e;\n    }\n\n    double to_yaw() const {\n        return std::atan2(2.0 * (w * z + x * y), 1.0 - 2.0 * (y * y + z * z));\n    }\n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/pose2d_8hpp/","title":"File pose2d.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; derived &gt; pose2d.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/derived/orientation.hpp\"</code></li> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> <li><code>#include \"conduit_types/header.hpp\"</code></li> <li><code>#include \"conduit_types/primitives/vec2.hpp\"</code></li> </ul>"},{"location":"conduit_types/pose2d_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/pose2d_8hpp/#classes","title":"Classes","text":"Type Name struct Pose2D 2D pose with position and orientation. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/pose2d.hpp</code></p>"},{"location":"conduit_types/pose2d_8hpp_source/","title":"File pose2d.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; derived &gt; pose2d.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/derived/orientation.hpp\"\n#include \"conduit_types/fixed_message_type.hpp\"\n#include \"conduit_types/header.hpp\"\n#include \"conduit_types/primitives/vec2.hpp\"\n\nnamespace conduit {\n\nstruct Pose2D : FixedMessageType {\n    Header header;            \n    Vec2 position;            \n    Orientation orientation;  \n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/pose3d_8hpp/","title":"File pose3d.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; derived &gt; pose3d.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/derived/orientation.hpp\"</code></li> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> <li><code>#include \"conduit_types/header.hpp\"</code></li> <li><code>#include \"conduit_types/primitives/vec3.hpp\"</code></li> </ul>"},{"location":"conduit_types/pose3d_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/pose3d_8hpp/#classes","title":"Classes","text":"Type Name struct Pose3D 3D pose with position and orientation. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/pose3d.hpp</code></p>"},{"location":"conduit_types/pose3d_8hpp_source/","title":"File pose3d.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; derived &gt; pose3d.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/derived/orientation.hpp\"\n#include \"conduit_types/fixed_message_type.hpp\"\n#include \"conduit_types/header.hpp\"\n#include \"conduit_types/primitives/vec3.hpp\"\n\nnamespace conduit {\n\nstruct Pose3D : FixedMessageType {\n    Header header;            \n    Vec3 position;            \n    Orientation orientation;  \n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/twist_8hpp/","title":"File twist.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; derived &gt; twist.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> <li><code>#include \"conduit_types/header.hpp\"</code></li> <li><code>#include \"conduit_types/primitives/vec3.hpp\"</code></li> </ul>"},{"location":"conduit_types/twist_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/twist_8hpp/#classes","title":"Classes","text":"Type Name struct Twist Linear and angular velocity in 3D. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/derived/twist.hpp</code></p>"},{"location":"conduit_types/twist_8hpp_source/","title":"File twist.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; derived &gt; twist.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/fixed_message_type.hpp\"\n#include \"conduit_types/header.hpp\"\n#include \"conduit_types/primitives/vec3.hpp\"\n\nnamespace conduit {\n\nstruct Twist : FixedMessageType {\n    Header header;   \n    Vec3 linear;     \n    Vec3 angular;    \n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/dir_5abad28eb9f480620bca24dc64f0d7e4/","title":"Dir packages/conduit_types/include/conduit_types/primitives","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives</p>"},{"location":"conduit_types/dir_5abad28eb9f480620bca24dc64f0d7e4/#files","title":"Files","text":"Type Name file bool.hpp file double.hpp file int.hpp file time.hpp file uint.hpp file vec2.hpp file vec3.hpp <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/</code></p>"},{"location":"conduit_types/bool_8hpp/","title":"File bool.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; bool.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> </ul>"},{"location":"conduit_types/bool_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/bool_8hpp/#classes","title":"Classes","text":"Type Name struct Bool Fixed-size boolean message type. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/bool.hpp</code></p>"},{"location":"conduit_types/bool_8hpp_source/","title":"File bool.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; bool.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/fixed_message_type.hpp\"\n\nnamespace conduit {\n\nstruct Bool : public FixedMessageType {\n    bool value;  \n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/double_8hpp/","title":"File double.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; double.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> </ul>"},{"location":"conduit_types/double_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/double_8hpp/#classes","title":"Classes","text":"Type Name struct Double Fixed-size double-precision floating point message type. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/double.hpp</code></p>"},{"location":"conduit_types/double_8hpp_source/","title":"File double.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; double.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/fixed_message_type.hpp\"\n\nnamespace conduit {\n\nstruct Double : public FixedMessageType {\n    double value;  \n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/int_8hpp/","title":"File int.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; int.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"conduit_types/int_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/int_8hpp/#classes","title":"Classes","text":"Type Name struct Int Fixed-size signed 64-bit integer message type. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/int.hpp</code></p>"},{"location":"conduit_types/int_8hpp_source/","title":"File int.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; int.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/fixed_message_type.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace conduit {\n\nstruct Int : public FixedMessageType {\n    int64_t value;  \n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/time_8hpp/","title":"File time.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; time.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"conduit_types/time_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/time_8hpp/#classes","title":"Classes","text":"Type Name struct Time Fixed-size timestamp message type. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/time.hpp</code></p>"},{"location":"conduit_types/time_8hpp_source/","title":"File time.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; time.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/fixed_message_type.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace conduit {\n\nstruct Time : public FixedMessageType {\n    uint64_t nanoseconds;  \n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/uint_8hpp/","title":"File uint.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; uint.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> <li><code>#include &lt;cstdint&gt;</code></li> </ul>"},{"location":"conduit_types/uint_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/uint_8hpp/#classes","title":"Classes","text":"Type Name struct Uint Fixed-size unsigned 64-bit integer message type. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/uint.hpp</code></p>"},{"location":"conduit_types/uint_8hpp_source/","title":"File uint.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; uint.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/fixed_message_type.hpp\"\n\n#include &lt;cstdint&gt;\n\nnamespace conduit {\n\nstruct Uint : public FixedMessageType {\n    uint64_t value;  \n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/vec2_8hpp/","title":"File vec2.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; vec2.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> </ul>"},{"location":"conduit_types/vec2_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/vec2_8hpp/#classes","title":"Classes","text":"Type Name struct Vec2 Fixed-size 2D vector message type. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/vec2.hpp</code></p>"},{"location":"conduit_types/vec2_8hpp_source/","title":"File vec2.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; vec2.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/fixed_message_type.hpp\"\n\nnamespace conduit {\n\nstruct Vec2 : FixedMessageType {\n    double x;  \n    double y;  \n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/vec3_8hpp/","title":"File vec3.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; vec3.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_types/fixed_message_type.hpp\"</code></li> </ul>"},{"location":"conduit_types/vec3_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_types/vec3_8hpp/#classes","title":"Classes","text":"Type Name struct Vec3 Fixed-size 3D vector message type. <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/primitives/vec3.hpp</code></p>"},{"location":"conduit_types/vec3_8hpp_source/","title":"File vec3.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; primitives &gt; vec3.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_types/fixed_message_type.hpp\"\n\nnamespace conduit {\n\nstruct Vec3 : FixedMessageType {\n    double x;  \n    double y;  \n    double z;  \n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/variable__message__type_8hpp/","title":"File variable_message_type.hpp","text":"<p>FileList &gt; conduit_types &gt; include &gt; conduit_types &gt; variable_message_type.hpp</p> <p>Go to the source code of this file</p> <p>Base class and compile-time validation for variable-size messages. More...</p> <ul> <li><code>#include &lt;cstddef&gt;</code></li> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;type_traits&gt;</code></li> </ul>"},{"location":"conduit_types/variable__message__type_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit namespace detail"},{"location":"conduit_types/variable__message__type_8hpp/#classes","title":"Classes","text":"Type Name class VariableMessageType Base class for variable-size messages requiring serialization."},{"location":"conduit_types/variable__message__type_8hpp/#detailed-description","title":"Detailed Description","text":"<p>Rules for variable message types: * Derive from VariableMessageType * Implement serialized_size() and serialize(uint8_t*) * Provide a static deserialize(const uint8_t*, size_t) -&gt; T method * Must NOT be trivially copyable (enforced as sanity check)</p> <p>See also: validate_variable_message_type, FixedMessageType </p> <p>The documentation for this class was generated from the following file <code>packages/conduit_types/include/conduit_types/variable_message_type.hpp</code></p>"},{"location":"conduit_types/variable__message__type_8hpp_source/","title":"File variable_message_type.hpp","text":"<p>File List &gt; conduit_types &gt; include &gt; conduit_types &gt; variable_message_type.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n\n#include &lt;cstddef&gt;\n#include &lt;cstdint&gt;\n#include &lt;type_traits&gt;\n\nnamespace conduit {\n\nclass VariableMessageType {\npublic:\n    virtual ~VariableMessageType() = default;\n\n    virtual size_t serialized_size() const = 0;\n\n    virtual void serialize(uint8_t* buffer) const = 0;\n\nprotected:\n    VariableMessageType() = default;\n};\n\nnamespace detail {\n\ntemplate &lt;typename T, typename = void&gt;\nstruct has_deserialize : std::false_type {};\n\ntemplate &lt;typename T&gt;\nstruct has_deserialize&lt;T,\n    std::void_t&lt;decltype(T::deserialize(std::declval&lt;const uint8_t*&gt;(), std::declval&lt;size_t&gt;()))&gt;&gt;\n    : std::is_same&lt;T, decltype(T::deserialize(std::declval&lt;const uint8_t*&gt;(), std::declval&lt;size_t&gt;()))&gt; {};\n\n}  // namespace detail\n\ntemplate &lt;typename T&gt;\nconstexpr void validate_variable_message_type() {\n    static_assert(std::is_base_of_v&lt;VariableMessageType, T&gt;,\n        \"T must derive from VariableMessageType\");\n    static_assert(!std::is_trivially_copyable_v&lt;T&gt;,\n        \"T must not be trivially copyable (variable message types require serialization)\");\n    static_assert(detail::has_deserialize&lt;T&gt;::value,\n        \"T must provide static T deserialize(const uint8_t*, size_t)\");\n}\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_types/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace conduit <ul> <li>namespace detail </li> </ul> </li> </ul>"},{"location":"conduit_types/classes/","title":"Class Index","text":""},{"location":"conduit_types/classes/#b","title":"b","text":"<ul> <li>Bool (conduit)</li> </ul>"},{"location":"conduit_types/classes/#d","title":"d","text":"<ul> <li>Double (conduit)</li> </ul>"},{"location":"conduit_types/classes/#f","title":"f","text":"<ul> <li>FixedMessageType (conduit)</li> </ul>"},{"location":"conduit_types/classes/#h","title":"h","text":"<ul> <li>Header (conduit)</li> </ul>"},{"location":"conduit_types/classes/#i","title":"i","text":"<ul> <li>Imu (conduit)</li> <li>Int (conduit)</li> </ul>"},{"location":"conduit_types/classes/#o","title":"o","text":"<ul> <li>Odometry (conduit)</li> <li>Orientation (conduit)</li> </ul>"},{"location":"conduit_types/classes/#p","title":"p","text":"<ul> <li>Pose2D (conduit)</li> <li>Pose3D (conduit)</li> </ul>"},{"location":"conduit_types/classes/#r","title":"r","text":"<ul> <li>ReadBuffer (conduit)</li> </ul>"},{"location":"conduit_types/classes/#t","title":"t","text":"<ul> <li>Time (conduit)</li> <li>Twist (conduit)</li> </ul>"},{"location":"conduit_types/classes/#u","title":"u","text":"<ul> <li>Uint (conduit)</li> </ul>"},{"location":"conduit_types/classes/#v","title":"v","text":"<ul> <li>VariableMessageType (conduit)</li> <li>Vec2 (conduit)</li> <li>Vec3 (conduit)</li> </ul>"},{"location":"conduit_types/classes/#w","title":"w","text":"<ul> <li>WriteBuffer (conduit)</li> </ul>"},{"location":"conduit_types/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class conduit::ReadBuffer Sequential binary reader for deserializing message fields. </li> <li>class conduit::VariableMessageType Base class for variable-size messages requiring serialization. </li> <li>class conduit::WriteBuffer Sequential binary writer for serializing message fields. </li> <li>struct conduit::FixedMessageType Base class for fixed-size, trivially copyable message types. <ul> <li>struct conduit::Bool Fixed-size boolean message type. </li> <li>struct conduit::Double Fixed-size double-precision floating point message type. </li> <li>struct conduit::Imu Inertial Measurement Unit data (orientation, angular velocity, linear acceleration). </li> <li>struct conduit::Int Fixed-size signed 64-bit integer message type. </li> <li>struct conduit::Odometry Odometry message with pose and velocity.</li> <li>struct conduit::Orientation Quaternion orientation (x, y, z, w) with Euler angle conversions. </li> <li>struct conduit::Pose2D 2D pose with position and orientation. </li> <li>struct conduit::Pose3D 3D pose with position and orientation. </li> <li>struct conduit::Time Fixed-size timestamp message type. </li> <li>struct conduit::Twist Linear and angular velocity in 3D. </li> <li>struct conduit::Uint Fixed-size unsigned 64-bit integer message type. </li> <li>struct conduit::Vec2 Fixed-size 2D vector message type. </li> <li>struct conduit::Vec3 Fixed-size 3D vector message type. </li> </ul> </li> <li>struct conduit::Header Common message header with timestamp and coordinate frame. </li> </ul>"},{"location":"conduit_types/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"conduit_types/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"conduit_types/class_members/","title":"Class Members","text":""},{"location":"conduit_types/class_members/#a","title":"a","text":"<ul> <li>angular_velocity (conduit::Imu, conduit::Odometry)</li> <li>angular (conduit::Twist)</li> </ul>"},{"location":"conduit_types/class_members/#c","title":"c","text":"<ul> <li>child_frame (conduit::Odometry)</li> </ul>"},{"location":"conduit_types/class_members/#f","title":"f","text":"<ul> <li>FixedMessageType (conduit::FixedMessageType)</li> <li>frame (conduit::Header)</li> <li>from_euler (conduit::Orientation)</li> <li>from_yaw (conduit::Orientation)</li> </ul>"},{"location":"conduit_types/class_members/#h","title":"h","text":"<ul> <li>header (conduit::Imu, conduit::Odometry, conduit::Pose2D, conduit::Pose3D, conduit::Twist)</li> </ul>"},{"location":"conduit_types/class_members/#l","title":"l","text":"<ul> <li>linear_acceleration (conduit::Imu)</li> <li>linear_velocity (conduit::Odometry)</li> <li>linear (conduit::Twist)</li> </ul>"},{"location":"conduit_types/class_members/#n","title":"n","text":"<ul> <li>nanoseconds (conduit::Time)</li> </ul>"},{"location":"conduit_types/class_members/#o","title":"o","text":"<ul> <li>orientation (conduit::Imu, conduit::Pose2D, conduit::Pose3D)</li> </ul>"},{"location":"conduit_types/class_members/#p","title":"p","text":"<ul> <li>pose (conduit::Odometry)</li> <li>position (conduit::Pose2D, conduit::Pose3D)</li> <li>ptr_ (conduit::ReadBuffer, conduit::WriteBuffer)</li> </ul>"},{"location":"conduit_types/class_members/#r","title":"r","text":"<ul> <li>ReadBuffer (conduit::ReadBuffer)</li> <li>read (conduit::ReadBuffer)</li> </ul>"},{"location":"conduit_types/class_members/#s","title":"s","text":"<ul> <li>serialize (conduit::VariableMessageType)</li> <li>serialized_size (conduit::VariableMessageType)</li> <li>size_of (conduit::WriteBuffer)</li> </ul>"},{"location":"conduit_types/class_members/#t","title":"t","text":"<ul> <li>timestamp_ns (conduit::Header)</li> <li>to_euler (conduit::Orientation)</li> <li>to_yaw (conduit::Orientation)</li> </ul>"},{"location":"conduit_types/class_members/#v","title":"v","text":"<ul> <li>value (conduit::Bool, conduit::Double, conduit::Int, conduit::Uint)</li> <li>VariableMessageType (conduit::VariableMessageType)</li> </ul>"},{"location":"conduit_types/class_members/#w","title":"w","text":"<ul> <li>w (conduit::Orientation)</li> <li>WriteBuffer (conduit::WriteBuffer)</li> <li>write (conduit::WriteBuffer)</li> </ul>"},{"location":"conduit_types/class_members/#x","title":"x","text":"<ul> <li>x (conduit::Orientation, conduit::Vec2, conduit::Vec3)</li> </ul>"},{"location":"conduit_types/class_members/#y","title":"y","text":"<ul> <li>y (conduit::Orientation, conduit::Vec2, conduit::Vec3)</li> </ul>"},{"location":"conduit_types/class_members/#z","title":"z","text":"<ul> <li>z (conduit::Orientation, conduit::Vec3)</li> </ul>"},{"location":"conduit_types/class_members/#_1","title":"~","text":"<ul> <li>~VariableMessageType (conduit::VariableMessageType)</li> </ul>"},{"location":"conduit_types/class_member_functions/","title":"Class Member Functions","text":""},{"location":"conduit_types/class_member_functions/#f","title":"f","text":"<ul> <li>FixedMessageType (conduit::FixedMessageType)</li> <li>from_euler (conduit::Orientation)</li> <li>from_yaw (conduit::Orientation)</li> </ul>"},{"location":"conduit_types/class_member_functions/#r","title":"r","text":"<ul> <li>ReadBuffer (conduit::ReadBuffer)</li> <li>read (conduit::ReadBuffer)</li> </ul>"},{"location":"conduit_types/class_member_functions/#s","title":"s","text":"<ul> <li>serialize (conduit::VariableMessageType)</li> <li>serialized_size (conduit::VariableMessageType)</li> <li>size_of (conduit::WriteBuffer)</li> </ul>"},{"location":"conduit_types/class_member_functions/#t","title":"t","text":"<ul> <li>to_euler (conduit::Orientation)</li> <li>to_yaw (conduit::Orientation)</li> </ul>"},{"location":"conduit_types/class_member_functions/#v","title":"v","text":"<ul> <li>VariableMessageType (conduit::VariableMessageType)</li> </ul>"},{"location":"conduit_types/class_member_functions/#w","title":"w","text":"<ul> <li>WriteBuffer (conduit::WriteBuffer)</li> <li>write (conduit::WriteBuffer)</li> </ul>"},{"location":"conduit_types/class_member_functions/#_1","title":"~","text":"<ul> <li>~VariableMessageType (conduit::VariableMessageType)</li> </ul>"},{"location":"conduit_types/class_member_variables/","title":"Class Member Variables","text":""},{"location":"conduit_types/class_member_variables/#a","title":"a","text":"<ul> <li>angular_velocity (conduit::Imu, conduit::Odometry)</li> <li>angular (conduit::Twist)</li> </ul>"},{"location":"conduit_types/class_member_variables/#c","title":"c","text":"<ul> <li>child_frame (conduit::Odometry)</li> </ul>"},{"location":"conduit_types/class_member_variables/#f","title":"f","text":"<ul> <li>frame (conduit::Header)</li> </ul>"},{"location":"conduit_types/class_member_variables/#h","title":"h","text":"<ul> <li>header (conduit::Imu, conduit::Odometry, conduit::Pose2D, conduit::Pose3D, conduit::Twist)</li> </ul>"},{"location":"conduit_types/class_member_variables/#l","title":"l","text":"<ul> <li>linear_acceleration (conduit::Imu)</li> <li>linear_velocity (conduit::Odometry)</li> <li>linear (conduit::Twist)</li> </ul>"},{"location":"conduit_types/class_member_variables/#n","title":"n","text":"<ul> <li>nanoseconds (conduit::Time)</li> </ul>"},{"location":"conduit_types/class_member_variables/#o","title":"o","text":"<ul> <li>orientation (conduit::Imu, conduit::Pose2D, conduit::Pose3D)</li> </ul>"},{"location":"conduit_types/class_member_variables/#p","title":"p","text":"<ul> <li>pose (conduit::Odometry)</li> <li>position (conduit::Pose2D, conduit::Pose3D)</li> <li>ptr_ (conduit::ReadBuffer, conduit::WriteBuffer)</li> </ul>"},{"location":"conduit_types/class_member_variables/#t","title":"t","text":"<ul> <li>timestamp_ns (conduit::Header)</li> </ul>"},{"location":"conduit_types/class_member_variables/#v","title":"v","text":"<ul> <li>value (conduit::Bool, conduit::Double, conduit::Int, conduit::Uint)</li> </ul>"},{"location":"conduit_types/class_member_variables/#w","title":"w","text":"<ul> <li>w (conduit::Orientation)</li> </ul>"},{"location":"conduit_types/class_member_variables/#x","title":"x","text":"<ul> <li>x (conduit::Orientation, conduit::Vec2, conduit::Vec3)</li> </ul>"},{"location":"conduit_types/class_member_variables/#y","title":"y","text":"<ul> <li>y (conduit::Orientation, conduit::Vec2, conduit::Vec3)</li> </ul>"},{"location":"conduit_types/class_member_variables/#z","title":"z","text":"<ul> <li>z (conduit::Orientation, conduit::Vec3)</li> </ul>"},{"location":"conduit_types/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"conduit_types/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"conduit_types/namespace_members/","title":"Namespace Members","text":""},{"location":"conduit_types/namespace_members/#e","title":"e","text":"<ul> <li>EulerOrder (conduit)</li> </ul>"},{"location":"conduit_types/namespace_members/#s","title":"s","text":"<ul> <li>set_frame (conduit)</li> </ul>"},{"location":"conduit_types/namespace_members/#v","title":"v","text":"<ul> <li>validate_fixed_message_type (conduit)</li> <li>validate_variable_message_type (conduit)</li> </ul>"},{"location":"conduit_types/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"conduit_types/namespace_member_functions/#s","title":"s","text":"<ul> <li>set_frame (conduit)</li> </ul>"},{"location":"conduit_types/namespace_member_functions/#v","title":"v","text":"<ul> <li>validate_fixed_message_type (conduit)</li> <li>validate_variable_message_type (conduit)</li> </ul>"},{"location":"conduit_types/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"conduit_types/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"conduit_types/namespace_member_enums/","title":"Namespace Member Enums","text":""},{"location":"conduit_types/namespace_member_enums/#e","title":"e","text":"<ul> <li>EulerOrder (conduit)</li> </ul>"},{"location":"conduit_types/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"conduit_types/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"conduit_types/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"conduit_types/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"conduit_tank/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace conduit <ul> <li>class Tank MCAP-based message recorder with Zstd/LZ4 compression. </li> </ul> </li> </ul>"},{"location":"conduit_tank/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir packages <ul> <li>dir conduit_tank <ul> <li>dir include <ul> <li>dir conduit_tank <ul> <li>file tank.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"conduit_tank/namespaceconduit/","title":"Namespace conduit","text":"<p>Namespace List &gt; conduit</p>"},{"location":"conduit_tank/namespaceconduit/#classes","title":"Classes","text":"Type Name class Tank MCAP-based message recorder with Zstd/LZ4 compression. <p>The documentation for this class was generated from the following file <code>packages/conduit_tank/include/conduit_tank/tank.hpp</code></p>"},{"location":"conduit_tank/classconduit_1_1Tank/","title":"Class conduit::Tank","text":"<p>ClassList &gt; conduit &gt; Tank</p> <p>MCAP-based message recorder with Zstd/LZ4 compression. More...</p> <ul> <li><code>#include &lt;tank.hpp&gt;</code></li> </ul>"},{"location":"conduit_tank/classconduit_1_1Tank/#public-functions","title":"Public Functions","text":"Type Name Tank (const std::string &amp; output_path) Construct a recorder targeting the given output file. Tank (const Tank &amp;) = delete Tank (Tank &amp;&amp;) = delete void add_topic (const std::string &amp; topic) Add a topic to record (must be called before start() ). uint64_t message_count () constGet the total number of messages recorded so far. Tank &amp; operator= (const Tank &amp;) = delete Tank &amp; operator= (Tank &amp;&amp;) = delete bool recording () constCheck if the recorder is currently active. void start () Start recording messages from all added topics. void stop () Stop recording and finalize the MCAP file. ~Tank ()"},{"location":"conduit_tank/classconduit_1_1Tank/#detailed-description","title":"Detailed Description","text":"<p>Records messages from one or more topics into an MCAP file. Topics must be added before calling start(). The recorded file can be replayed with the conduit CLI tools.</p> <p>See also: Node </p>"},{"location":"conduit_tank/classconduit_1_1Tank/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_tank/classconduit_1_1Tank/#function-tank-13","title":"function Tank [1/3]","text":"<p>Construct a recorder targeting the given output file. <pre><code>explicit conduit::Tank::Tank (\n    const std::string &amp; output_path\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>output_path</code> Path to the MCAP output file. </li> </ul>"},{"location":"conduit_tank/classconduit_1_1Tank/#function-tank-23","title":"function Tank [2/3]","text":"<pre><code>conduit::Tank::Tank (\n    const Tank &amp;\n) = delete\n</code></pre>"},{"location":"conduit_tank/classconduit_1_1Tank/#function-tank-33","title":"function Tank [3/3]","text":"<pre><code>conduit::Tank::Tank (\n    Tank &amp;&amp;\n) = delete\n</code></pre>"},{"location":"conduit_tank/classconduit_1_1Tank/#function-add_topic","title":"function add_topic","text":"<p>Add a topic to record (must be called before start() ). <pre><code>void conduit::Tank::add_topic (\n    const std::string &amp; topic\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>topic</code> Topic name to subscribe to and record. </li> </ul>"},{"location":"conduit_tank/classconduit_1_1Tank/#function-message_count","title":"function message_count","text":"<p>Get the total number of messages recorded so far. <pre><code>uint64_t conduit::Tank::message_count () const\n</code></pre></p> <p>Returns:</p> <p>Message count. </p>"},{"location":"conduit_tank/classconduit_1_1Tank/#function-operator","title":"function operator=","text":"<pre><code>Tank &amp; conduit::Tank::operator= (\n    const Tank &amp;\n) = delete\n</code></pre>"},{"location":"conduit_tank/classconduit_1_1Tank/#function-operator_1","title":"function operator=","text":"<pre><code>Tank &amp; conduit::Tank::operator= (\n    Tank &amp;&amp;\n) = delete\n</code></pre>"},{"location":"conduit_tank/classconduit_1_1Tank/#function-recording","title":"function recording","text":"<p>Check if the recorder is currently active. <pre><code>bool conduit::Tank::recording () const\n</code></pre></p> <p>Returns:</p> <p>true if recording is in progress. </p>"},{"location":"conduit_tank/classconduit_1_1Tank/#function-start","title":"function start","text":"<p>Start recording messages from all added topics. <pre><code>void conduit::Tank::start () \n</code></pre></p>"},{"location":"conduit_tank/classconduit_1_1Tank/#function-stop","title":"function stop","text":"<p>Stop recording and finalize the MCAP file. <pre><code>void conduit::Tank::stop () \n</code></pre></p>"},{"location":"conduit_tank/classconduit_1_1Tank/#function-tank","title":"function ~Tank","text":"<pre><code>conduit::Tank::~Tank () \n</code></pre> <p>The documentation for this class was generated from the following file <code>packages/conduit_tank/include/conduit_tank/tank.hpp</code></p>"},{"location":"conduit_tank/dir_93501a11e921083efbd154e0cdff5f10/","title":"Dir packages","text":"<p>FileList &gt; packages</p>"},{"location":"conduit_tank/dir_93501a11e921083efbd154e0cdff5f10/#directories","title":"Directories","text":"Type Name dir conduit_tank <p>The documentation for this class was generated from the following file <code>packages/</code></p>"},{"location":"conduit_tank/dir_54377b39698324c476f35b30c1643219/","title":"Dir packages/conduit_tank","text":"<p>FileList &gt; conduit_tank</p>"},{"location":"conduit_tank/dir_54377b39698324c476f35b30c1643219/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>packages/conduit_tank/</code></p>"},{"location":"conduit_tank/dir_d2ca71ae5994f61a5fce416b805b40c7/","title":"Dir packages/conduit_tank/include","text":"<p>FileList &gt; conduit_tank &gt; include</p>"},{"location":"conduit_tank/dir_d2ca71ae5994f61a5fce416b805b40c7/#directories","title":"Directories","text":"Type Name dir conduit_tank <p>The documentation for this class was generated from the following file <code>packages/conduit_tank/include/</code></p>"},{"location":"conduit_tank/dir_81a44e27c6bd9edd39a953e81d05e4bb/","title":"Dir packages/conduit_tank/include/conduit_tank","text":"<p>FileList &gt; conduit_tank &gt; include &gt; conduit_tank</p>"},{"location":"conduit_tank/dir_81a44e27c6bd9edd39a953e81d05e4bb/#files","title":"Files","text":"Type Name file tank.hpp <p>The documentation for this class was generated from the following file <code>packages/conduit_tank/include/conduit_tank/</code></p>"},{"location":"conduit_tank/tank_8hpp/","title":"File tank.hpp","text":"<p>FileList &gt; conduit_tank &gt; include &gt; conduit_tank &gt; tank.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;cstdint&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"conduit_tank/tank_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit"},{"location":"conduit_tank/tank_8hpp/#classes","title":"Classes","text":"Type Name class Tank MCAP-based message recorder with Zstd/LZ4 compression. <p>The documentation for this class was generated from the following file <code>packages/conduit_tank/include/conduit_tank/tank.hpp</code></p>"},{"location":"conduit_tank/tank_8hpp_source/","title":"File tank.hpp","text":"<p>File List &gt; conduit_tank &gt; include &gt; conduit_tank &gt; tank.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;cstdint&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n\nnamespace conduit {\n\nclass Tank {\npublic:\n    explicit Tank(const std::string&amp; output_path);\n    ~Tank();\n\n    // No copy, no move\n    Tank(const Tank&amp;) = delete;\n    Tank&amp; operator=(const Tank&amp;) = delete;\n    Tank(Tank&amp;&amp;) = delete;\n    Tank&amp; operator=(Tank&amp;&amp;) = delete;\n\n    void add_topic(const std::string&amp; topic);\n\n    void start();\n\n    void stop();\n\n    bool recording() const;\n\n    uint64_t message_count() const;\n\nprivate:\n    struct Impl;\n    std::unique_ptr&lt;Impl&gt; impl_;\n};\n\n}  // namespace conduit\n</code></pre>"},{"location":"conduit_tank/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace conduit </li> </ul>"},{"location":"conduit_tank/classes/","title":"Class Index","text":""},{"location":"conduit_tank/classes/#t","title":"t","text":"<ul> <li>Tank (conduit)</li> </ul>"},{"location":"conduit_tank/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class conduit::Tank MCAP-based message recorder with Zstd/LZ4 compression. </li> </ul>"},{"location":"conduit_tank/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"conduit_tank/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"conduit_tank/class_members/","title":"Class Members","text":""},{"location":"conduit_tank/class_members/#a","title":"a","text":"<ul> <li>add_topic (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_members/#i","title":"i","text":"<ul> <li>impl_ (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_members/#m","title":"m","text":"<ul> <li>message_count (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_members/#o","title":"o","text":"<ul> <li>operator= (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_members/#r","title":"r","text":"<ul> <li>recording (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_members/#s","title":"s","text":"<ul> <li>start (conduit::Tank)</li> <li>stop (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_members/#t","title":"t","text":"<ul> <li>Tank (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_members/#_1","title":"~","text":"<ul> <li>~Tank (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_member_functions/","title":"Class Member Functions","text":""},{"location":"conduit_tank/class_member_functions/#a","title":"a","text":"<ul> <li>add_topic (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_member_functions/#m","title":"m","text":"<ul> <li>message_count (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_member_functions/#r","title":"r","text":"<ul> <li>recording (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_member_functions/#s","title":"s","text":"<ul> <li>start (conduit::Tank)</li> <li>stop (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_member_functions/#t","title":"t","text":"<ul> <li>Tank (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_member_functions/#_1","title":"~","text":"<ul> <li>~Tank (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_member_variables/","title":"Class Member Variables","text":""},{"location":"conduit_tank/class_member_variables/#i","title":"i","text":"<ul> <li>impl_ (conduit::Tank)</li> </ul>"},{"location":"conduit_tank/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"conduit_tank/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"conduit_tank/namespace_members/","title":"Namespace Members","text":"<p>Nothing related to Namespace Members found.</p>"},{"location":"conduit_tank/namespace_member_functions/","title":"Namespace Member Functions","text":"<p>Nothing related to Namespace Member Functions found.</p>"},{"location":"conduit_tank/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"conduit_tank/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":"<p>Nothing related to Namespace Member Typedefs found.</p>"},{"location":"conduit_tank/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"conduit_tank/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"conduit_tank/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"conduit_tank/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"conduit_tank/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"},{"location":"conduit_flow/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace conduit <ul> <li>namespace flow <ul> <li>class Executor Executes a flow configuration (startup and shutdown sequences). </li> <li>struct ExecutorOptions Options for the flow executor. </li> <li>struct FlowConfig Complete flow configuration with startup and shutdown sequences. </li> <li>struct Group Parallel group: start multiple nodes simultaneously. </li> <li>struct NodeConfig Configuration for a single node in a flow. </li> <li>struct WaitDuration Wait step: pause for a fixed duration. </li> <li>struct WaitTopics Wait step: block until specified topics exist in shared memory. </li> </ul> </li> </ul> </li> </ul>"},{"location":"conduit_flow/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir packages <ul> <li>dir conduit_flow <ul> <li>dir include <ul> <li>dir conduit_flow <ul> <li>file executor.hpp </li> <li>file flow.hpp </li> <li>file parser.hpp </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"conduit_flow/namespaceconduit/","title":"Namespace conduit","text":"<p>Namespace List &gt; conduit</p>"},{"location":"conduit_flow/namespaceconduit/#namespaces","title":"Namespaces","text":"Type Name namespace flow <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/executor.hpp</code></p>"},{"location":"conduit_flow/namespaceconduit_1_1flow/","title":"Namespace conduit::flow","text":"<p>Namespace List &gt; conduit &gt; flow</p>"},{"location":"conduit_flow/namespaceconduit_1_1flow/#classes","title":"Classes","text":"Type Name class Executor Executes a flow configuration (startup and shutdown sequences). struct ExecutorOptions Options for the flow executor. struct FlowConfig Complete flow configuration with startup and shutdown sequences. struct Group Parallel group: start multiple nodes simultaneously. struct NodeConfig Configuration for a single node in a flow. struct WaitDuration Wait step: pause for a fixed duration. struct WaitTopics Wait step: block until specified topics exist in shared memory."},{"location":"conduit_flow/namespaceconduit_1_1flow/#public-types","title":"Public Types","text":"Type Name typedef std::variant&lt; NodeConfig, WaitDuration, WaitTopics, Group &gt; Step A single step in a flow sequence."},{"location":"conduit_flow/namespaceconduit_1_1flow/#public-functions","title":"Public Functions","text":"Type Name FlowConfig parse_file (const std::string &amp; path) Parse a .flow.yaml file into a FlowConfig . FlowConfig parse_string (const std::string &amp; yaml) Parse a YAML string into a FlowConfig (useful for testing)."},{"location":"conduit_flow/namespaceconduit_1_1flow/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"conduit_flow/namespaceconduit_1_1flow/#typedef-step","title":"typedef Step","text":"<p>A single step in a flow sequence. <pre><code>using conduit::flow::Step = typedef std::variant&lt;NodeConfig, WaitDuration, WaitTopics, Group&gt;;\n</code></pre></p>"},{"location":"conduit_flow/namespaceconduit_1_1flow/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_flow/namespaceconduit_1_1flow/#function-parse_file","title":"function parse_file","text":"<p>Parse a .flow.yaml file into a FlowConfig . <pre><code>FlowConfig conduit::flow::parse_file (\n    const std::string &amp; path\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>path</code> Filesystem path to the YAML file. </li> </ul> <p>Returns:</p> <p>Parsed flow configuration. </p> <p>Exception:</p> <ul> <li><code>std::runtime_error</code> If the file cannot be read or parsed. </li> </ul>"},{"location":"conduit_flow/namespaceconduit_1_1flow/#function-parse_string","title":"function parse_string","text":"<p>Parse a YAML string into a FlowConfig (useful for testing). <pre><code>FlowConfig conduit::flow::parse_string (\n    const std::string &amp; yaml\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>yaml</code> YAML content as a string. </li> </ul> <p>Returns:</p> <p>Parsed flow configuration. </p> <p>Exception:</p> <ul> <li><code>std::runtime_error</code> If the YAML is invalid. </li> </ul> <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/executor.hpp</code></p>"},{"location":"conduit_flow/classconduit_1_1flow_1_1Executor/","title":"Class conduit::flow::Executor","text":"<p>ClassList &gt; conduit &gt; flow &gt; Executor</p> <p>Executes a flow configuration (startup and shutdown sequences). More...</p> <ul> <li><code>#include &lt;executor.hpp&gt;</code></li> </ul>"},{"location":"conduit_flow/classconduit_1_1flow_1_1Executor/#public-functions","title":"Public Functions","text":"Type Name Executor (ExecutorOptions options={}) Construct an executor with the given options. Executor (const Executor &amp;) = delete Executor &amp; operator= (const Executor &amp;) = delete int run (const FlowConfig &amp; config) Run the flow (blocks until shutdown completes). bool running () constCheck if the executor is currently running a flow. void shutdown () Request graceful shutdown of all running nodes. ~Executor ()"},{"location":"conduit_flow/classconduit_1_1flow_1_1Executor/#detailed-description","title":"Detailed Description","text":"<p>Launches nodes as child processes, handles wait steps and parallel groups, and manages graceful shutdown on SIGINT/SIGTERM. </p>"},{"location":"conduit_flow/classconduit_1_1flow_1_1Executor/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"conduit_flow/classconduit_1_1flow_1_1Executor/#function-executor-12","title":"function Executor [1/2]","text":"<p>Construct an executor with the given options. <pre><code>explicit conduit::flow::Executor::Executor (\n    ExecutorOptions options={}\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>options</code> Execution options. </li> </ul>"},{"location":"conduit_flow/classconduit_1_1flow_1_1Executor/#function-executor-22","title":"function Executor [2/2]","text":"<pre><code>conduit::flow::Executor::Executor (\n    const Executor &amp;\n) = delete\n</code></pre>"},{"location":"conduit_flow/classconduit_1_1flow_1_1Executor/#function-operator","title":"function operator=","text":"<pre><code>Executor &amp; conduit::flow::Executor::operator= (\n    const Executor &amp;\n) = delete\n</code></pre>"},{"location":"conduit_flow/classconduit_1_1flow_1_1Executor/#function-run","title":"function run","text":"<p>Run the flow (blocks until shutdown completes). <pre><code>int conduit::flow::Executor::run (\n    const FlowConfig &amp; config\n) \n</code></pre></p> <p>Parameters:</p> <ul> <li><code>config</code> The flow configuration to execute. </li> </ul> <p>Returns:</p> <p>Exit code (0 on clean shutdown). </p>"},{"location":"conduit_flow/classconduit_1_1flow_1_1Executor/#function-running","title":"function running","text":"<p>Check if the executor is currently running a flow. <pre><code>bool conduit::flow::Executor::running () const\n</code></pre></p> <p>Returns:</p> <p>true if run() is active. </p>"},{"location":"conduit_flow/classconduit_1_1flow_1_1Executor/#function-shutdown","title":"function shutdown","text":"<p>Request graceful shutdown of all running nodes. <pre><code>void conduit::flow::Executor::shutdown () \n</code></pre></p>"},{"location":"conduit_flow/classconduit_1_1flow_1_1Executor/#function-executor","title":"function ~Executor","text":"<pre><code>conduit::flow::Executor::~Executor () \n</code></pre> <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/executor.hpp</code></p>"},{"location":"conduit_flow/structconduit_1_1flow_1_1ExecutorOptions/","title":"Struct conduit::flow::ExecutorOptions","text":"<p>ClassList &gt; conduit &gt; flow &gt; ExecutorOptions</p> <p>Options for the flow executor. </p> <ul> <li><code>#include &lt;executor.hpp&gt;</code></li> </ul>"},{"location":"conduit_flow/structconduit_1_1flow_1_1ExecutorOptions/#public-attributes","title":"Public Attributes","text":"Type Name bool verbose   = <code>true</code>Print startup/shutdown progress to stdout."},{"location":"conduit_flow/structconduit_1_1flow_1_1ExecutorOptions/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_flow/structconduit_1_1flow_1_1ExecutorOptions/#variable-verbose","title":"variable verbose","text":"<p>Print startup/shutdown progress to stdout. <pre><code>bool conduit::flow::ExecutorOptions::verbose;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/executor.hpp</code></p>"},{"location":"conduit_flow/structconduit_1_1flow_1_1FlowConfig/","title":"Struct conduit::flow::FlowConfig","text":"<p>ClassList &gt; conduit &gt; flow &gt; FlowConfig</p> <p>Complete flow configuration with startup and shutdown sequences. </p> <ul> <li><code>#include &lt;flow.hpp&gt;</code></li> </ul>"},{"location":"conduit_flow/structconduit_1_1flow_1_1FlowConfig/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; Step &gt; shutdown Ordered shutdown steps (default: reverse of startup). std::vector&lt; Step &gt; startup Ordered startup steps."},{"location":"conduit_flow/structconduit_1_1flow_1_1FlowConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_flow/structconduit_1_1flow_1_1FlowConfig/#variable-shutdown","title":"variable shutdown","text":"<p>Ordered shutdown steps (default: reverse of startup). <pre><code>std::vector&lt;Step&gt; conduit::flow::FlowConfig::shutdown;\n</code></pre></p>"},{"location":"conduit_flow/structconduit_1_1flow_1_1FlowConfig/#variable-startup","title":"variable startup","text":"<p>Ordered startup steps. <pre><code>std::vector&lt;Step&gt; conduit::flow::FlowConfig::startup;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/flow.hpp</code></p>"},{"location":"conduit_flow/structconduit_1_1flow_1_1Group/","title":"Struct conduit::flow::Group","text":"<p>ClassList &gt; conduit &gt; flow &gt; Group</p> <p>Parallel group: start multiple nodes simultaneously. </p> <ul> <li><code>#include &lt;flow.hpp&gt;</code></li> </ul>"},{"location":"conduit_flow/structconduit_1_1flow_1_1Group/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; NodeConfig &gt; nodes Nodes to launch in parallel."},{"location":"conduit_flow/structconduit_1_1flow_1_1Group/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_flow/structconduit_1_1flow_1_1Group/#variable-nodes","title":"variable nodes","text":"<p>Nodes to launch in parallel. <pre><code>std::vector&lt;NodeConfig&gt; conduit::flow::Group::nodes;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/flow.hpp</code></p>"},{"location":"conduit_flow/structconduit_1_1flow_1_1NodeConfig/","title":"Struct conduit::flow::NodeConfig","text":"<p>ClassList &gt; conduit &gt; flow &gt; NodeConfig</p> <p>Configuration for a single node in a flow. </p> <ul> <li><code>#include &lt;flow.hpp&gt;</code></li> </ul>"},{"location":"conduit_flow/structconduit_1_1flow_1_1NodeConfig/#public-attributes","title":"Public Attributes","text":"Type Name std::vector&lt; std::string &gt; args Command-line arguments. std::map&lt; std::string, std::string &gt; env Environment variable overrides. std::string exec Executable path or command. std::string name Logical node name. std::string working_dir Working directory for the process."},{"location":"conduit_flow/structconduit_1_1flow_1_1NodeConfig/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_flow/structconduit_1_1flow_1_1NodeConfig/#variable-args","title":"variable args","text":"<p>Command-line arguments. <pre><code>std::vector&lt;std::string&gt; conduit::flow::NodeConfig::args;\n</code></pre></p>"},{"location":"conduit_flow/structconduit_1_1flow_1_1NodeConfig/#variable-env","title":"variable env","text":"<p>Environment variable overrides. <pre><code>std::map&lt;std::string, std::string&gt; conduit::flow::NodeConfig::env;\n</code></pre></p>"},{"location":"conduit_flow/structconduit_1_1flow_1_1NodeConfig/#variable-exec","title":"variable exec","text":"<p>Executable path or command. <pre><code>std::string conduit::flow::NodeConfig::exec;\n</code></pre></p>"},{"location":"conduit_flow/structconduit_1_1flow_1_1NodeConfig/#variable-name","title":"variable name","text":"<p>Logical node name. <pre><code>std::string conduit::flow::NodeConfig::name;\n</code></pre></p>"},{"location":"conduit_flow/structconduit_1_1flow_1_1NodeConfig/#variable-working_dir","title":"variable working_dir","text":"<p>Working directory for the process. <pre><code>std::string conduit::flow::NodeConfig::working_dir;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/flow.hpp</code></p>"},{"location":"conduit_flow/structconduit_1_1flow_1_1WaitDuration/","title":"Struct conduit::flow::WaitDuration","text":"<p>ClassList &gt; conduit &gt; flow &gt; WaitDuration</p> <p>Wait step: pause for a fixed duration. </p> <ul> <li><code>#include &lt;flow.hpp&gt;</code></li> </ul>"},{"location":"conduit_flow/structconduit_1_1flow_1_1WaitDuration/#public-attributes","title":"Public Attributes","text":"Type Name std::chrono::milliseconds duration Time to wait."},{"location":"conduit_flow/structconduit_1_1flow_1_1WaitDuration/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_flow/structconduit_1_1flow_1_1WaitDuration/#variable-duration","title":"variable duration","text":"<p>Time to wait. <pre><code>std::chrono::milliseconds conduit::flow::WaitDuration::duration;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/flow.hpp</code></p>"},{"location":"conduit_flow/structconduit_1_1flow_1_1WaitTopics/","title":"Struct conduit::flow::WaitTopics","text":"<p>ClassList &gt; conduit &gt; flow &gt; WaitTopics</p> <p>Wait step: block until specified topics exist in shared memory. </p> <ul> <li><code>#include &lt;flow.hpp&gt;</code></li> </ul>"},{"location":"conduit_flow/structconduit_1_1flow_1_1WaitTopics/#public-attributes","title":"Public Attributes","text":"Type Name std::chrono::milliseconds timeout   = <code>{30000}</code>Maximum wait time (default 30s). std::vector&lt; std::string &gt; topics Topic names to wait for."},{"location":"conduit_flow/structconduit_1_1flow_1_1WaitTopics/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"conduit_flow/structconduit_1_1flow_1_1WaitTopics/#variable-timeout","title":"variable timeout","text":"<p>Maximum wait time (default 30s). <pre><code>std::chrono::milliseconds conduit::flow::WaitTopics::timeout;\n</code></pre></p>"},{"location":"conduit_flow/structconduit_1_1flow_1_1WaitTopics/#variable-topics","title":"variable topics","text":"<p>Topic names to wait for. <pre><code>std::vector&lt;std::string&gt; conduit::flow::WaitTopics::topics;\n</code></pre></p> <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/flow.hpp</code></p>"},{"location":"conduit_flow/dir_93501a11e921083efbd154e0cdff5f10/","title":"Dir packages","text":"<p>FileList &gt; packages</p>"},{"location":"conduit_flow/dir_93501a11e921083efbd154e0cdff5f10/#directories","title":"Directories","text":"Type Name dir conduit_flow <p>The documentation for this class was generated from the following file <code>packages/</code></p>"},{"location":"conduit_flow/dir_0d13c9fe7659a255034ddc49adfce1eb/","title":"Dir packages/conduit_flow","text":"<p>FileList &gt; conduit_flow</p>"},{"location":"conduit_flow/dir_0d13c9fe7659a255034ddc49adfce1eb/#directories","title":"Directories","text":"Type Name dir include <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/</code></p>"},{"location":"conduit_flow/dir_fb8309341c6f8659fa21828ed1417524/","title":"Dir packages/conduit_flow/include","text":"<p>FileList &gt; conduit_flow &gt; include</p>"},{"location":"conduit_flow/dir_fb8309341c6f8659fa21828ed1417524/#directories","title":"Directories","text":"Type Name dir conduit_flow <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/</code></p>"},{"location":"conduit_flow/dir_288fb1ab69c9ae4a94f91c5befae3aa0/","title":"Dir packages/conduit_flow/include/conduit_flow","text":"<p>FileList &gt; conduit_flow &gt; include &gt; conduit_flow</p>"},{"location":"conduit_flow/dir_288fb1ab69c9ae4a94f91c5befae3aa0/#files","title":"Files","text":"Type Name file executor.hpp file flow.hpp file parser.hpp <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/</code></p>"},{"location":"conduit_flow/executor_8hpp/","title":"File executor.hpp","text":"<p>FileList &gt; conduit_flow &gt; include &gt; conduit_flow &gt; executor.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_flow/flow.hpp\"</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"conduit_flow/executor_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit namespace flow"},{"location":"conduit_flow/executor_8hpp/#classes","title":"Classes","text":"Type Name class Executor Executes a flow configuration (startup and shutdown sequences). struct ExecutorOptions Options for the flow executor. <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/executor.hpp</code></p>"},{"location":"conduit_flow/executor_8hpp_source/","title":"File executor.hpp","text":"<p>File List &gt; conduit_flow &gt; include &gt; conduit_flow &gt; executor.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_flow/flow.hpp\"\n#include &lt;memory&gt;\n\nnamespace conduit::flow {\n\nstruct ExecutorOptions {\n    bool verbose = true;  \n};\n\nclass Executor {\npublic:\n    explicit Executor(ExecutorOptions options = {});\n    ~Executor();\n\n    Executor(const Executor&amp;) = delete;\n    Executor&amp; operator=(const Executor&amp;) = delete;\n\n    int run(const FlowConfig&amp; config);\n\n    void shutdown();\n\n    bool running() const;\n\nprivate:\n    struct Impl;\n    std::unique_ptr&lt;Impl&gt; impl_;\n};\n\n}  // namespace conduit::flow\n</code></pre>"},{"location":"conduit_flow/flow_8hpp/","title":"File flow.hpp","text":"<p>FileList &gt; conduit_flow &gt; include &gt; conduit_flow &gt; flow.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;map&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;variant&gt;</code></li> <li><code>#include &lt;vector&gt;</code></li> </ul>"},{"location":"conduit_flow/flow_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit namespace flow"},{"location":"conduit_flow/flow_8hpp/#classes","title":"Classes","text":"Type Name struct FlowConfig Complete flow configuration with startup and shutdown sequences. struct Group Parallel group: start multiple nodes simultaneously. struct NodeConfig Configuration for a single node in a flow. struct WaitDuration Wait step: pause for a fixed duration. struct WaitTopics Wait step: block until specified topics exist in shared memory. <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/flow.hpp</code></p>"},{"location":"conduit_flow/flow_8hpp_source/","title":"File flow.hpp","text":"<p>File List &gt; conduit_flow &gt; include &gt; conduit_flow &gt; flow.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;map&gt;\n#include &lt;string&gt;\n#include &lt;variant&gt;\n#include &lt;vector&gt;\n\nnamespace conduit::flow {\n\nstruct NodeConfig {\n    std::string name;                            \n    std::string exec;                            \n    std::vector&lt;std::string&gt; args;               \n    std::map&lt;std::string, std::string&gt; env;      \n    std::string working_dir;                     \n};\n\nstruct WaitDuration {\n    std::chrono::milliseconds duration;  \n};\n\nstruct WaitTopics {\n    std::vector&lt;std::string&gt; topics;             \n    std::chrono::milliseconds timeout{30000};    \n};\n\nstruct Group {\n    std::vector&lt;NodeConfig&gt; nodes;  \n};\n\nusing Step = std::variant&lt;NodeConfig, WaitDuration, WaitTopics, Group&gt;;\n\nstruct FlowConfig {\n    std::vector&lt;Step&gt; startup;   \n    std::vector&lt;Step&gt; shutdown;  \n};\n\n}  // namespace conduit::flow\n</code></pre>"},{"location":"conduit_flow/parser_8hpp/","title":"File parser.hpp","text":"<p>FileList &gt; conduit_flow &gt; include &gt; conduit_flow &gt; parser.hpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"conduit_flow/flow.hpp\"</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"conduit_flow/parser_8hpp/#namespaces","title":"Namespaces","text":"Type Name namespace conduit namespace flow <p>The documentation for this class was generated from the following file <code>packages/conduit_flow/include/conduit_flow/parser.hpp</code></p>"},{"location":"conduit_flow/parser_8hpp_source/","title":"File parser.hpp","text":"<p>File List &gt; conduit_flow &gt; include &gt; conduit_flow &gt; parser.hpp</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include \"conduit_flow/flow.hpp\"\n#include &lt;string&gt;\n\nnamespace conduit::flow {\n\nFlowConfig parse_file(const std::string&amp; path);\n\nFlowConfig parse_string(const std::string&amp; yaml);\n\n}  // namespace conduit::flow\n</code></pre>"},{"location":"conduit_flow/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace conduit <ul> <li>namespace flow </li> </ul> </li> </ul>"},{"location":"conduit_flow/classes/","title":"Class Index","text":""},{"location":"conduit_flow/classes/#e","title":"e","text":"<ul> <li>Executor (conduit::flow)</li> <li>ExecutorOptions (conduit::flow)</li> </ul>"},{"location":"conduit_flow/classes/#f","title":"f","text":"<ul> <li>FlowConfig (conduit::flow)</li> </ul>"},{"location":"conduit_flow/classes/#g","title":"g","text":"<ul> <li>Group (conduit::flow)</li> </ul>"},{"location":"conduit_flow/classes/#n","title":"n","text":"<ul> <li>NodeConfig (conduit::flow)</li> </ul>"},{"location":"conduit_flow/classes/#w","title":"w","text":"<ul> <li>WaitDuration (conduit::flow)</li> <li>WaitTopics (conduit::flow)</li> </ul>"},{"location":"conduit_flow/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class conduit::flow::Executor Executes a flow configuration (startup and shutdown sequences). </li> <li>struct conduit::flow::ExecutorOptions Options for the flow executor. </li> <li>struct conduit::flow::FlowConfig Complete flow configuration with startup and shutdown sequences. </li> <li>struct conduit::flow::Group Parallel group: start multiple nodes simultaneously. </li> <li>struct conduit::flow::NodeConfig Configuration for a single node in a flow. </li> <li>struct conduit::flow::WaitDuration Wait step: pause for a fixed duration. </li> <li>struct conduit::flow::WaitTopics Wait step: block until specified topics exist in shared memory. </li> </ul>"},{"location":"conduit_flow/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"conduit_flow/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"conduit_flow/class_members/","title":"Class Members","text":""},{"location":"conduit_flow/class_members/#a","title":"a","text":"<ul> <li>args (conduit::flow::NodeConfig)</li> </ul>"},{"location":"conduit_flow/class_members/#d","title":"d","text":"<ul> <li>duration (conduit::flow::WaitDuration)</li> </ul>"},{"location":"conduit_flow/class_members/#e","title":"e","text":"<ul> <li>Executor (conduit::flow::Executor)</li> <li>env (conduit::flow::NodeConfig)</li> <li>exec (conduit::flow::NodeConfig)</li> </ul>"},{"location":"conduit_flow/class_members/#i","title":"i","text":"<ul> <li>impl_ (conduit::flow::Executor)</li> </ul>"},{"location":"conduit_flow/class_members/#n","title":"n","text":"<ul> <li>nodes (conduit::flow::Group)</li> <li>name (conduit::flow::NodeConfig)</li> </ul>"},{"location":"conduit_flow/class_members/#o","title":"o","text":"<ul> <li>operator= (conduit::flow::Executor)</li> </ul>"},{"location":"conduit_flow/class_members/#r","title":"r","text":"<ul> <li>run (conduit::flow::Executor)</li> <li>running (conduit::flow::Executor)</li> </ul>"},{"location":"conduit_flow/class_members/#s","title":"s","text":"<ul> <li>shutdown (conduit::flow::Executor, conduit::flow::FlowConfig)</li> <li>startup (conduit::flow::FlowConfig)</li> </ul>"},{"location":"conduit_flow/class_members/#t","title":"t","text":"<ul> <li>timeout (conduit::flow::WaitTopics)</li> <li>topics (conduit::flow::WaitTopics)</li> </ul>"},{"location":"conduit_flow/class_members/#v","title":"v","text":"<ul> <li>verbose (conduit::flow::ExecutorOptions)</li> </ul>"},{"location":"conduit_flow/class_members/#w","title":"w","text":"<ul> <li>working_dir (conduit::flow::NodeConfig)</li> </ul>"},{"location":"conduit_flow/class_members/#_1","title":"~","text":"<ul> <li>~Executor (conduit::flow::Executor)</li> </ul>"},{"location":"conduit_flow/class_member_functions/","title":"Class Member Functions","text":""},{"location":"conduit_flow/class_member_functions/#e","title":"e","text":"<ul> <li>Executor (conduit::flow::Executor)</li> </ul>"},{"location":"conduit_flow/class_member_functions/#o","title":"o","text":"<ul> <li>operator= (conduit::flow::Executor)</li> </ul>"},{"location":"conduit_flow/class_member_functions/#r","title":"r","text":"<ul> <li>run (conduit::flow::Executor)</li> <li>running (conduit::flow::Executor)</li> </ul>"},{"location":"conduit_flow/class_member_functions/#s","title":"s","text":"<ul> <li>shutdown (conduit::flow::Executor)</li> </ul>"},{"location":"conduit_flow/class_member_functions/#_1","title":"~","text":"<ul> <li>~Executor (conduit::flow::Executor)</li> </ul>"},{"location":"conduit_flow/class_member_variables/","title":"Class Member Variables","text":""},{"location":"conduit_flow/class_member_variables/#a","title":"a","text":"<ul> <li>args (conduit::flow::NodeConfig)</li> </ul>"},{"location":"conduit_flow/class_member_variables/#d","title":"d","text":"<ul> <li>duration (conduit::flow::WaitDuration)</li> </ul>"},{"location":"conduit_flow/class_member_variables/#e","title":"e","text":"<ul> <li>env (conduit::flow::NodeConfig)</li> <li>exec (conduit::flow::NodeConfig)</li> </ul>"},{"location":"conduit_flow/class_member_variables/#i","title":"i","text":"<ul> <li>impl_ (conduit::flow::Executor)</li> </ul>"},{"location":"conduit_flow/class_member_variables/#n","title":"n","text":"<ul> <li>nodes (conduit::flow::Group)</li> <li>name (conduit::flow::NodeConfig)</li> </ul>"},{"location":"conduit_flow/class_member_variables/#s","title":"s","text":"<ul> <li>shutdown (conduit::flow::FlowConfig)</li> <li>startup (conduit::flow::FlowConfig)</li> </ul>"},{"location":"conduit_flow/class_member_variables/#t","title":"t","text":"<ul> <li>timeout (conduit::flow::WaitTopics)</li> <li>topics (conduit::flow::WaitTopics)</li> </ul>"},{"location":"conduit_flow/class_member_variables/#v","title":"v","text":"<ul> <li>verbose (conduit::flow::ExecutorOptions)</li> </ul>"},{"location":"conduit_flow/class_member_variables/#w","title":"w","text":"<ul> <li>working_dir (conduit::flow::NodeConfig)</li> </ul>"},{"location":"conduit_flow/class_member_typedefs/","title":"Class Member Typedefs","text":"<p>Nothing related to Class Member Typedefs found.</p>"},{"location":"conduit_flow/class_member_enums/","title":"Class Member Enums","text":"<p>Nothing related to Class Member Enums found.</p>"},{"location":"conduit_flow/namespace_members/","title":"Namespace Members","text":""},{"location":"conduit_flow/namespace_members/#p","title":"p","text":"<ul> <li>parse_file (conduit::flow)</li> <li>parse_string (conduit::flow)</li> </ul>"},{"location":"conduit_flow/namespace_members/#s","title":"s","text":"<ul> <li>Step (conduit::flow)</li> </ul>"},{"location":"conduit_flow/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"conduit_flow/namespace_member_functions/#p","title":"p","text":"<ul> <li>parse_file (conduit::flow)</li> <li>parse_string (conduit::flow)</li> </ul>"},{"location":"conduit_flow/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"conduit_flow/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"conduit_flow/namespace_member_typedefs/#s","title":"s","text":"<ul> <li>Step (conduit::flow)</li> </ul>"},{"location":"conduit_flow/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"conduit_flow/functions/","title":"Functions","text":"<p>Nothing related to Functions found.</p>"},{"location":"conduit_flow/macros/","title":"Macros","text":"<p>Nothing related to Macros found.</p>"},{"location":"conduit_flow/variables/","title":"Variables","text":"<p>Nothing related to Variables found.</p>"},{"location":"conduit_flow/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}